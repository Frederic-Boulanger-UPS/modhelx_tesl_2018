/*
 * generated by Xtext
 */
package fr.supelec.tesl.lang.validation

import fr.supelec.tesl.lang.tesl.ImplicationRelation
import fr.supelec.tesl.lang.tesl.TeslPackage
import org.eclipse.xtext.validation.Check
import fr.supelec.tesl.lang.tesl.SameTagsExpr
import fr.supelec.tesl.lang.tesl.TagExpr

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class TESLValidator extends AbstractTESLValidator {

	@Check
	def checkClockDoesNotImplyItself(ImplicationRelation r) {
		if(r.source == r.target) {
			error('Clock implies itself', r, TeslPackage.Literals.IMPLICATION_RELATION__TARGET);
		}
	}
	
	@Check
	def tagExprSameClockTypes(TagExpr s) {
		if(s.clockX != null && s.clockY != null) {
			if(s.clockX.type != s.clockY.type) {
				error('Tag relation between clocks of different types: ' + s.clockX.type + ', ' + s.clockY.type, TeslPackage.Literals.TAG_EXPR__EQ);
			}
		}
	}
	
	/* 
	@Check
	def checkTagRelationReferencesTheIntendedClocks(TagRelation r) {
		if(r.tagEqA != null && r.tagEqB != null) {
			if(r.tagEqA.expr != null)
				r.tagEqA.expr.doCheckReferencesOnlyOneClock(r.tagEqB.clock, r, TeslPackage.Literals.TAG_RELATION__TAG_EQ_A)
			
		if(r.tagEqB != null)
			r.tagEqB.expr.doCheckReferencesOnlyOneClock(r.tagEqA.clock, r, TeslPackage.Literals.TAG_RELATION__TAG_EQ_B)
			
		}
	}
	*/
	
	/* 
	@Check
	def checkTracePragmaOnOrOff(TracePragma tp) {
		if(! #["on", "off"].contains(tp.value)) {
			error('@trace must be set to "on" or "off"', tp, TeslPackage.Literals.TRACE_PRAGMA__VALUE);
		}
	}
	*/
	
	/* 
	@Check
	def checkTimeDelayedQualifierReferencesTheIntendedClocks(TimeDelayedQualifier q) {
		var reffed = q.timeExpr.clocksReferencedByExpr()
		
		var implicationRelation = (q.eContainer as ImplicationRelation)
		reffed.removeAll(implicationRelation.source, implicationRelation.target)
		
		if(reffed.size() > 0) {
			error('Extraneous clocks in expression: ' + reffed.map[ name ], q, 
				TeslPackage.Literals.TIME_DELAYED_QUALIFIER__TIME_EXPR)
		}
		
		return reffed
	}
	* */
	
	/**
	 * Adds an extension method to Expression, that returns the set of 
	 * referenced clocks.
	 */
	 /* 
	def dispatch Set<Clock> clocksReferencedByExpr(Expr e) {
		return Collections.EMPTY_SET
	}

	def dispatch Set<Clock> clocksReferencedByExpr(BinOperation e) {
		var l = new HashSet<Clock>()
		
		if(e.left != null) l.addAll(e.left.clocksReferencedByExpr())
		if(e.right != null) l.addAll(e.right.clocksReferencedByExpr())
		
		return l
	}

	def dispatch Set<Clock> clocksReferencedByExpr(ClockRef e) {
		var l = new HashSet<Clock>()
		
		l.add(e.clock)
		
		return l
	}
	* 
	*/
	/* End of clocksReferencedByExpr() */
	
	/**
	 * Raises an error if the expression does not references c, or contains 
	 * references to clocks other than c. The last two arguments (the enclosing
	 * TagRelation and the reference to the current expression) are for
	 * generating the error message.
	 */
	 /* 
	def doCheckReferencesOnlyOneClock(Expr e, Clock c, TagRelation r, EReference exprDesignator) {
		var reffed = e.clocksReferencedByExpr()
		
		if(! reffed.contains(c)) {
			error('Clock ' + c.name + ' must appear in expression', r, exprDesignator)
		}
		
		reffed.remove(c)
		
		if(reffed.size() > 0) {
			error('Extraneous clocks in expression: ' + reffed.map[ name ], r, exprDesignator)
		}
	}
	* 
	*/

//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}
