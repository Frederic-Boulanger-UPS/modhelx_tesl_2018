/*
 * generated by Xtext
 */
package fr.supelec.tesl.lang.serializer;

import com.google.inject.Inject;
import fr.supelec.tesl.lang.services.TESLGrammarAccess;
import fr.supelec.tesl.lang.tesl.AwaitImplication;
import fr.supelec.tesl.lang.tesl.BinOp;
import fr.supelec.tesl.lang.tesl.Clock;
import fr.supelec.tesl.lang.tesl.ClockItem;
import fr.supelec.tesl.lang.tesl.DecimalCast;
import fr.supelec.tesl.lang.tesl.DecimalValue;
import fr.supelec.tesl.lang.tesl.DelayedQualifier;
import fr.supelec.tesl.lang.tesl.DoubleCalcPragma;
import fr.supelec.tesl.lang.tesl.DumpResultPragma;
import fr.supelec.tesl.lang.tesl.EveryQualifier;
import fr.supelec.tesl.lang.tesl.FilteredQualifier;
import fr.supelec.tesl.lang.tesl.FloatCast;
import fr.supelec.tesl.lang.tesl.FloatValue;
import fr.supelec.tesl.lang.tesl.ImplicationRelation;
import fr.supelec.tesl.lang.tesl.IntCast;
import fr.supelec.tesl.lang.tesl.IntegerValue;
import fr.supelec.tesl.lang.tesl.Let;
import fr.supelec.tesl.lang.tesl.LetValue;
import fr.supelec.tesl.lang.tesl.MaxstepPragma;
import fr.supelec.tesl.lang.tesl.NextQualifier;
import fr.supelec.tesl.lang.tesl.OutputPragma;
import fr.supelec.tesl.lang.tesl.Pattern;
import fr.supelec.tesl.lang.tesl.PeriodicQualifier;
import fr.supelec.tesl.lang.tesl.RationalCast;
import fr.supelec.tesl.lang.tesl.RationalValue;
import fr.supelec.tesl.lang.tesl.Specification;
import fr.supelec.tesl.lang.tesl.SporadicQualifier;
import fr.supelec.tesl.lang.tesl.StopPragma;
import fr.supelec.tesl.lang.tesl.SustainedQualifier;
import fr.supelec.tesl.lang.tesl.TagExpr;
import fr.supelec.tesl.lang.tesl.TagRelation;
import fr.supelec.tesl.lang.tesl.TagrefPragma;
import fr.supelec.tesl.lang.tesl.TeslPackage;
import fr.supelec.tesl.lang.tesl.TimeDelayedQualifier;
import fr.supelec.tesl.lang.tesl.TracePragma;
import fr.supelec.tesl.lang.tesl.WhenQualifier;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class TESLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TESLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TeslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TeslPackage.AWAIT_IMPLICATION:
				sequence_AwaitImplication(context, (AwaitImplication) semanticObject); 
				return; 
			case TeslPackage.BIN_OP:
				sequence_Factor_Term(context, (BinOp) semanticObject); 
				return; 
			case TeslPackage.CLOCK:
				sequence_Clock(context, (Clock) semanticObject); 
				return; 
			case TeslPackage.CLOCK_ITEM:
				sequence_ClockItem(context, (ClockItem) semanticObject); 
				return; 
			case TeslPackage.DECIMAL_CAST:
				sequence_DecimalCast(context, (DecimalCast) semanticObject); 
				return; 
			case TeslPackage.DECIMAL_VALUE:
				sequence_DecimalValue(context, (DecimalValue) semanticObject); 
				return; 
			case TeslPackage.DELAYED_QUALIFIER:
				sequence_DelayedQualifier(context, (DelayedQualifier) semanticObject); 
				return; 
			case TeslPackage.DOUBLE_CALC_PRAGMA:
				sequence_DoubleCalcPragma(context, (DoubleCalcPragma) semanticObject); 
				return; 
			case TeslPackage.DUMP_RESULT_PRAGMA:
				sequence_DumpResultPragma(context, (DumpResultPragma) semanticObject); 
				return; 
			case TeslPackage.EVERY_QUALIFIER:
				sequence_EveryQualifier(context, (EveryQualifier) semanticObject); 
				return; 
			case TeslPackage.FILTERED_QUALIFIER:
				sequence_FilteredQualifier(context, (FilteredQualifier) semanticObject); 
				return; 
			case TeslPackage.FLOAT_CAST:
				sequence_FloatCast(context, (FloatCast) semanticObject); 
				return; 
			case TeslPackage.FLOAT_VALUE:
				sequence_FloatValue(context, (FloatValue) semanticObject); 
				return; 
			case TeslPackage.IMPLICATION_RELATION:
				sequence_ImplicationRelation(context, (ImplicationRelation) semanticObject); 
				return; 
			case TeslPackage.INT_CAST:
				sequence_IntCast(context, (IntCast) semanticObject); 
				return; 
			case TeslPackage.INTEGER_VALUE:
				sequence_IntegerValue(context, (IntegerValue) semanticObject); 
				return; 
			case TeslPackage.LET:
				sequence_Let(context, (Let) semanticObject); 
				return; 
			case TeslPackage.LET_VALUE:
				sequence_LetValue(context, (LetValue) semanticObject); 
				return; 
			case TeslPackage.MAXSTEP_PRAGMA:
				sequence_MaxstepPragma(context, (MaxstepPragma) semanticObject); 
				return; 
			case TeslPackage.NEXT_QUALIFIER:
				sequence_NextQualifier(context, (NextQualifier) semanticObject); 
				return; 
			case TeslPackage.OUTPUT_PRAGMA:
				sequence_OutputPragma(context, (OutputPragma) semanticObject); 
				return; 
			case TeslPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case TeslPackage.PERIODIC_QUALIFIER:
				sequence_PeriodicQualifier(context, (PeriodicQualifier) semanticObject); 
				return; 
			case TeslPackage.RATIONAL_CAST:
				sequence_RationalCast(context, (RationalCast) semanticObject); 
				return; 
			case TeslPackage.RATIONAL_VALUE:
				sequence_RationalValue(context, (RationalValue) semanticObject); 
				return; 
			case TeslPackage.SPECIFICATION:
				sequence_Specification(context, (Specification) semanticObject); 
				return; 
			case TeslPackage.SPORADIC_QUALIFIER:
				sequence_SporadicQualifier(context, (SporadicQualifier) semanticObject); 
				return; 
			case TeslPackage.STOP_PRAGMA:
				sequence_StopPragma(context, (StopPragma) semanticObject); 
				return; 
			case TeslPackage.SUSTAINED_QUALIFIER:
				sequence_SustainedQualifier(context, (SustainedQualifier) semanticObject); 
				return; 
			case TeslPackage.TAG_EXPR:
				sequence_TagExpr(context, (TagExpr) semanticObject); 
				return; 
			case TeslPackage.TAG_RELATION:
				sequence_TagRelation(context, (TagRelation) semanticObject); 
				return; 
			case TeslPackage.TAGREF_PRAGMA:
				sequence_TagrefPragma(context, (TagrefPragma) semanticObject); 
				return; 
			case TeslPackage.TIME_DELAYED_QUALIFIER:
				sequence_TimeDelayedQualifier(context, (TimeDelayedQualifier) semanticObject); 
				return; 
			case TeslPackage.TRACE_PRAGMA:
				sequence_TracePragma(context, (TracePragma) semanticObject); 
				return; 
			case TeslPackage.WHEN_QUALIFIER:
				sequence_WhenQualifier(context, (WhenQualifier) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Relation returns AwaitImplication
	 *     AwaitImplication returns AwaitImplication
	 *
	 * Constraint:
	 *     (masters+=[Clock|ID]+ ((weak?='weak' | strong?='strong') reset=[Clock|ID])? target=[Clock|ID])
	 */
	protected void sequence_AwaitImplication(ISerializationContext context, AwaitImplication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClockItem returns ClockItem
	 *
	 * Constraint:
	 *     (clock=[Clock|ID] newName=ID?)
	 */
	protected void sequence_ClockItem(ISerializationContext context, ClockItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Clock returns Clock
	 *
	 * Constraint:
	 *     (nongreedy?='nongreedy'? type=Type name=ID qual=ClockQualifier?)
	 */
	protected void sequence_Clock(ISerializationContext context, Clock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DecimalCast
	 *     Term returns DecimalCast
	 *     Term.BinOp_1_0 returns DecimalCast
	 *     Factor returns DecimalCast
	 *     Factor.BinOp_1_0 returns DecimalCast
	 *     BasicExpr returns DecimalCast
	 *     Cast returns DecimalCast
	 *     DecimalCast returns DecimalCast
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_DecimalCast(ISerializationContext context, DecimalCast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.CAST__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.CAST__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecimalCastAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns DecimalValue
	 *     DecimalValue returns DecimalValue
	 *     Expression returns DecimalValue
	 *     Term returns DecimalValue
	 *     Term.BinOp_1_0 returns DecimalValue
	 *     Factor returns DecimalValue
	 *     Factor.BinOp_1_0 returns DecimalValue
	 *     BasicExpr returns DecimalValue
	 *
	 * Constraint:
	 *     (sign=OpTerm? value=BIG_DECIMAL)
	 */
	protected void sequence_DecimalValue(ISerializationContext context, DecimalValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImplicationQualifier returns DelayedQualifier
	 *     DelayedQualifier returns DelayedQualifier
	 *
	 * Constraint:
	 *     (immediately?='immediately'? count=Expression reset?='with'? clock=[Clock|ID])
	 */
	protected void sequence_DelayedQualifier(ISerializationContext context, DelayedQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pragma returns DoubleCalcPragma
	 *     DoubleCalcPragma returns DoubleCalcPragma
	 *
	 * Constraint:
	 *     (num_digits=BIG_INT (round?='(' rounding_mode=ROUNDING_MODE)?)
	 */
	protected void sequence_DoubleCalcPragma(ISerializationContext context, DoubleCalcPragma semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pragma returns DumpResultPragma
	 *     DumpResultPragma returns DumpResultPragma
	 *
	 * Constraint:
	 *     {DumpResultPragma}
	 */
	protected void sequence_DumpResultPragma(ISerializationContext context, DumpResultPragma semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImplicationQualifier returns EveryQualifier
	 *     EveryQualifier returns EveryQualifier
	 *
	 * Constraint:
	 *     (period=Expression (off?='starting' offset=Expression)?)
	 */
	protected void sequence_EveryQualifier(ISerializationContext context, EveryQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BinOp
	 *     Term returns BinOp
	 *     Term.BinOp_1_0 returns BinOp
	 *     Factor returns BinOp
	 *     Factor.BinOp_1_0 returns BinOp
	 *     BasicExpr returns BinOp
	 *
	 * Constraint:
	 *     ((left=Term_BinOp_1_0 op=OpTerm right=Factor) | (left=Factor_BinOp_1_0 op=OpFact right=BasicExpr))
	 */
	protected void sequence_Factor_Term(ISerializationContext context, BinOp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImplicationQualifier returns FilteredQualifier
	 *     FilteredQualifier returns FilteredQualifier
	 *
	 * Constraint:
	 *     pattern=Pattern
	 */
	protected void sequence_FilteredQualifier(ISerializationContext context, FilteredQualifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.FILTERED_QUALIFIER__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.FILTERED_QUALIFIER__PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFilteredQualifierAccess().getPatternPatternParserRuleCall_2_0(), semanticObject.getPattern());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FloatCast
	 *     Term returns FloatCast
	 *     Term.BinOp_1_0 returns FloatCast
	 *     Factor returns FloatCast
	 *     Factor.BinOp_1_0 returns FloatCast
	 *     BasicExpr returns FloatCast
	 *     Cast returns FloatCast
	 *     FloatCast returns FloatCast
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_FloatCast(ISerializationContext context, FloatCast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.CAST__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.CAST__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatCastAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns FloatValue
	 *     FloatValue returns FloatValue
	 *     Expression returns FloatValue
	 *     Term returns FloatValue
	 *     Term.BinOp_1_0 returns FloatValue
	 *     Factor returns FloatValue
	 *     Factor.BinOp_1_0 returns FloatValue
	 *     BasicExpr returns FloatValue
	 *
	 * Constraint:
	 *     (sign=OpTerm? value=FLOAT)
	 */
	protected void sequence_FloatValue(ISerializationContext context, FloatValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Relation returns ImplicationRelation
	 *     ImplicationRelation returns ImplicationRelation
	 *
	 * Constraint:
	 *     (source=[Clock|ID] qual=ImplicationQualifier? target=[Clock|ID])
	 */
	protected void sequence_ImplicationRelation(ISerializationContext context, ImplicationRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntCast
	 *     Term returns IntCast
	 *     Term.BinOp_1_0 returns IntCast
	 *     Factor returns IntCast
	 *     Factor.BinOp_1_0 returns IntCast
	 *     BasicExpr returns IntCast
	 *     Cast returns IntCast
	 *     IntCast returns IntCast
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_IntCast(ISerializationContext context, IntCast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.CAST__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.CAST__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntCastAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns IntegerValue
	 *     IntegerValue returns IntegerValue
	 *     Expression returns IntegerValue
	 *     Term returns IntegerValue
	 *     Term.BinOp_1_0 returns IntegerValue
	 *     Factor returns IntegerValue
	 *     Factor.BinOp_1_0 returns IntegerValue
	 *     BasicExpr returns IntegerValue
	 *
	 * Constraint:
	 *     (sign=OpTerm? value=BIG_INT)
	 */
	protected void sequence_IntegerValue(ISerializationContext context, IntegerValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns LetValue
	 *     LetValue returns LetValue
	 *     Expression returns LetValue
	 *     Term returns LetValue
	 *     Term.BinOp_1_0 returns LetValue
	 *     Factor returns LetValue
	 *     Factor.BinOp_1_0 returns LetValue
	 *     BasicExpr returns LetValue
	 *
	 * Constraint:
	 *     ref=[Let|ID]
	 */
	protected void sequence_LetValue(ISerializationContext context, LetValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.LET_VALUE__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.LET_VALUE__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetValueAccess().getRefLetIDTerminalRuleCall_1_0_1(), semanticObject.eGet(TeslPackage.Literals.LET_VALUE__REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Let returns Let
	 *
	 * Constraint:
	 *     (type=ValueType name=ID value=Expression)
	 */
	protected void sequence_Let(ISerializationContext context, Let semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.LET__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.LET__TYPE));
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.LET__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.LET__NAME));
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.LET__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.LET__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetAccess().getTypeValueTypeEnumRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getLetAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLetAccess().getValueExpressionParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pragma returns MaxstepPragma
	 *     MaxstepPragma returns MaxstepPragma
	 *
	 * Constraint:
	 *     value=Expression
	 */
	protected void sequence_MaxstepPragma(ISerializationContext context, MaxstepPragma semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.MAXSTEP_PRAGMA__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.MAXSTEP_PRAGMA__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxstepPragmaAccess().getValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImplicationQualifier returns NextQualifier
	 *     NextQualifier returns NextQualifier
	 *
	 * Constraint:
	 *     (strict?='strictly'? clock=[Clock|ID])
	 */
	protected void sequence_NextQualifier(ISerializationContext context, NextQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pragma returns OutputPragma
	 *     OutputPragma returns OutputPragma
	 *
	 * Constraint:
	 *     (
	 *         (type='vcd' | type='tikz' | type='svg') 
	 *         nodefcss?='no-default-css'? 
	 *         (
	 *             (
	 *                 (selection?='select' selectedClocks+=ClockItem selectedClocks+=ClockItem*) | 
	 *                 (window?='from' from=Expression to=Expression) | 
	 *                 (labelif+=[Clock|ID] labelif+=[Clock|ID]*) | 
	 *                 (xscaled?='xscale' xscale=Expression) | 
	 *                 border=STRING | 
	 *                 css=STRING | 
	 *                 jvs=STRING | 
	 *                 (standalone?='standalone' overwrite?='overwrite'?)
	 *             )? 
	 *             nodefcss?='no-default-css'?
	 *         )*
	 *     )
	 */
	protected void sequence_OutputPragma(ISerializationContext context, OutputPragma semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (skip=Expression keep=Expression (rep?='(' repskip=Expression repkeep=Expression)?)
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClockQualifier returns PeriodicQualifier
	 *     PeriodicQualifier returns PeriodicQualifier
	 *
	 * Constraint:
	 *     (period=Expression offset=Expression?)
	 */
	protected void sequence_PeriodicQualifier(ISerializationContext context, PeriodicQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RationalCast
	 *     Term returns RationalCast
	 *     Term.BinOp_1_0 returns RationalCast
	 *     Factor returns RationalCast
	 *     Factor.BinOp_1_0 returns RationalCast
	 *     BasicExpr returns RationalCast
	 *     Cast returns RationalCast
	 *     RationalCast returns RationalCast
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_RationalCast(ISerializationContext context, RationalCast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.CAST__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.CAST__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRationalCastAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Value returns RationalValue
	 *     RationalValue returns RationalValue
	 *     Expression returns RationalValue
	 *     Term returns RationalValue
	 *     Term.BinOp_1_0 returns RationalValue
	 *     Factor returns RationalValue
	 *     Factor.BinOp_1_0 returns RationalValue
	 *     BasicExpr returns RationalValue
	 *
	 * Constraint:
	 *     (sign=OpTerm? value=RATIONAL)
	 */
	protected void sequence_RationalValue(ISerializationContext context, RationalValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Specification returns Specification
	 *
	 * Constraint:
	 *     (decl+=Clock | rel+=Relation | let+=Let | pragmas+=Pragma)+
	 */
	protected void sequence_Specification(ISerializationContext context, Specification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClockQualifier returns SporadicQualifier
	 *     SporadicQualifier returns SporadicQualifier
	 *
	 * Constraint:
	 *     (instants+=Value instants+=Expression*)?
	 */
	protected void sequence_SporadicQualifier(ISerializationContext context, SporadicQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pragma returns StopPragma
	 *     StopPragma returns StopPragma
	 *
	 * Constraint:
	 *     clock=[Clock|ID]
	 */
	protected void sequence_StopPragma(ISerializationContext context, StopPragma semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.STOP_PRAGMA__CLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.STOP_PRAGMA__CLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStopPragmaAccess().getClockClockIDTerminalRuleCall_2_0_1(), semanticObject.eGet(TeslPackage.Literals.STOP_PRAGMA__CLOCK, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImplicationQualifier returns SustainedQualifier
	 *     SustainedQualifier returns SustainedQualifier
	 *
	 * Constraint:
	 *     (immediately?='immediately'? startClock=[Clock|ID] endClock=[Clock|ID] weakly?='weakly'?)
	 */
	protected void sequence_SustainedQualifier(ISerializationContext context, SustainedQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TagExpr returns TagExpr
	 *
	 * Constraint:
	 *     (clockY=[Clock|ID] valueA=Expression? clockX=[Clock|ID] valueN=BasicExpr? valueB=Expression?)
	 */
	protected void sequence_TagExpr(ISerializationContext context, TagExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Relation returns TagRelation
	 *     TagRelation returns TagRelation
	 *
	 * Constraint:
	 *     (expr=TagExpr | expr=TagExpr)
	 */
	protected void sequence_TagRelation(ISerializationContext context, TagRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pragma returns TagrefPragma
	 *     TagrefPragma returns TagrefPragma
	 *
	 * Constraint:
	 *     clock=[Clock|ID]
	 */
	protected void sequence_TagrefPragma(ISerializationContext context, TagrefPragma semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TeslPackage.Literals.TAGREF_PRAGMA__CLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TeslPackage.Literals.TAGREF_PRAGMA__CLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTagrefPragmaAccess().getClockClockIDTerminalRuleCall_1_0_1(), semanticObject.eGet(TeslPackage.Literals.TAGREF_PRAGMA__CLOCK, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImplicationQualifier returns TimeDelayedQualifier
	 *     TimeDelayedQualifier returns TimeDelayedQualifier
	 *
	 * Constraint:
	 *     (delay=Expression clock=[Clock|ID] (reset?='with' (immReset?='immediate' | strongReset?='strong')* resetClock=[Clock|ID])?)
	 */
	protected void sequence_TimeDelayedQualifier(ISerializationContext context, TimeDelayedQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pragma returns TracePragma
	 *     TracePragma returns TracePragma
	 *
	 * Constraint:
	 *     (kinds+=ID kinds+=ID*)
	 */
	protected void sequence_TracePragma(ISerializationContext context, TracePragma semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImplicationQualifier returns WhenQualifier
	 *     WhenQualifier returns WhenQualifier
	 *
	 * Constraint:
	 *     (not?='not'? clock=[Clock|ID])
	 */
	protected void sequence_WhenQualifier(ISerializationContext context, WhenQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
