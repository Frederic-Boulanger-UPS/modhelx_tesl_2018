/*
 * generated by Xtext
 */
package fr.supelec.tesl.lang.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;


@Singleton
public class TESLGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class SpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Specification");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cDeclAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cDeclClockParserRuleCall_0_0 = (RuleCall)cDeclAssignment_0.eContents().get(0);
		private final Assignment cRelAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cRelRelationParserRuleCall_1_0 = (RuleCall)cRelAssignment_1.eContents().get(0);
		private final Assignment cLetAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cLetLetParserRuleCall_2_0 = (RuleCall)cLetAssignment_2.eContents().get(0);
		private final Assignment cPragmasAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cPragmasPragmaParserRuleCall_3_0 = (RuleCall)cPragmasAssignment_3.eContents().get(0);
		
		//Specification:
		//	(decl+=Clock | rel+=Relation | let+=Let | pragmas+=Pragma)*;
		@Override public ParserRule getRule() { return rule; }

		//(decl+=Clock | rel+=Relation | let+=Let | pragmas+=Pragma)*
		public Alternatives getAlternatives() { return cAlternatives; }

		//decl+=Clock
		public Assignment getDeclAssignment_0() { return cDeclAssignment_0; }

		//Clock
		public RuleCall getDeclClockParserRuleCall_0_0() { return cDeclClockParserRuleCall_0_0; }

		//rel+=Relation
		public Assignment getRelAssignment_1() { return cRelAssignment_1; }

		//Relation
		public RuleCall getRelRelationParserRuleCall_1_0() { return cRelRelationParserRuleCall_1_0; }

		//let+=Let
		public Assignment getLetAssignment_2() { return cLetAssignment_2; }

		//Let
		public RuleCall getLetLetParserRuleCall_2_0() { return cLetLetParserRuleCall_2_0; }

		//pragmas+=Pragma
		public Assignment getPragmasAssignment_3() { return cPragmasAssignment_3; }

		//Pragma
		public RuleCall getPragmasPragmaParserRuleCall_3_0() { return cPragmasPragmaParserRuleCall_3_0; }
	}

	public class ClockElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Clock");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNongreedyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNongreedyNongreedyKeyword_0_0 = (Keyword)cNongreedyAssignment_0.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeTypeEnumRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Assignment cQualAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cQualClockQualifierParserRuleCall_3_0 = (RuleCall)cQualAssignment_3.eContents().get(0);
		
		//Clock:
		//	nongreedy?="nongreedy"? type=Type name=ID qual=ClockQualifier?;
		@Override public ParserRule getRule() { return rule; }

		//nongreedy?="nongreedy"? type=Type name=ID qual=ClockQualifier?
		public Group getGroup() { return cGroup; }

		//nongreedy?="nongreedy"?
		public Assignment getNongreedyAssignment_0() { return cNongreedyAssignment_0; }

		//"nongreedy"
		public Keyword getNongreedyNongreedyKeyword_0_0() { return cNongreedyNongreedyKeyword_0_0; }

		//type=Type
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//Type
		public RuleCall getTypeTypeEnumRuleCall_1_0() { return cTypeTypeEnumRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//qual=ClockQualifier?
		public Assignment getQualAssignment_3() { return cQualAssignment_3; }

		//ClockQualifier
		public RuleCall getQualClockQualifierParserRuleCall_3_0() { return cQualClockQualifierParserRuleCall_3_0; }
	}

	public class ClockQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.ClockQualifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPeriodicQualifierParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSporadicQualifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ClockQualifier:
		//	PeriodicQualifier | SporadicQualifier;
		@Override public ParserRule getRule() { return rule; }

		//PeriodicQualifier | SporadicQualifier
		public Alternatives getAlternatives() { return cAlternatives; }

		//PeriodicQualifier
		public RuleCall getPeriodicQualifierParserRuleCall_0() { return cPeriodicQualifierParserRuleCall_0; }

		//SporadicQualifier
		public RuleCall getSporadicQualifierParserRuleCall_1() { return cSporadicQualifierParserRuleCall_1; }
	}

	public class PeriodicQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.PeriodicQualifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPeriodicKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPeriodAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPeriodExpressionParserRuleCall_1_0 = (RuleCall)cPeriodAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cOffsetKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cOffsetAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cOffsetExpressionParserRuleCall_2_1_0 = (RuleCall)cOffsetAssignment_2_1.eContents().get(0);
		
		//PeriodicQualifier:
		//	"periodic" period=Expression ("offset" offset=Expression)?;
		@Override public ParserRule getRule() { return rule; }

		//"periodic" period=Expression ("offset" offset=Expression)?
		public Group getGroup() { return cGroup; }

		//"periodic"
		public Keyword getPeriodicKeyword_0() { return cPeriodicKeyword_0; }

		//period=Expression
		public Assignment getPeriodAssignment_1() { return cPeriodAssignment_1; }

		//Expression
		public RuleCall getPeriodExpressionParserRuleCall_1_0() { return cPeriodExpressionParserRuleCall_1_0; }

		//("offset" offset=Expression)?
		public Group getGroup_2() { return cGroup_2; }

		//"offset"
		public Keyword getOffsetKeyword_2_0() { return cOffsetKeyword_2_0; }

		//offset=Expression
		public Assignment getOffsetAssignment_2_1() { return cOffsetAssignment_2_1; }

		//Expression
		public RuleCall getOffsetExpressionParserRuleCall_2_1_0() { return cOffsetExpressionParserRuleCall_2_1_0; }
	}

	public class SporadicQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.SporadicQualifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSporadicQualifierAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSporadicKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cInstantsAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cInstantsValueParserRuleCall_2_0_0 = (RuleCall)cInstantsAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cInstantsAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cInstantsExpressionParserRuleCall_2_1_1_0 = (RuleCall)cInstantsAssignment_2_1_1.eContents().get(0);
		
		//SporadicQualifier:
		//	{SporadicQualifier} "sporadic" (instants+=Value ("," instants+=Expression)*)?;
		@Override public ParserRule getRule() { return rule; }

		//{SporadicQualifier} "sporadic" (instants+=Value ("," instants+=Expression)*)?
		public Group getGroup() { return cGroup; }

		//{SporadicQualifier}
		public Action getSporadicQualifierAction_0() { return cSporadicQualifierAction_0; }

		//"sporadic"
		public Keyword getSporadicKeyword_1() { return cSporadicKeyword_1; }

		//(instants+=Value ("," instants+=Expression)*)?
		public Group getGroup_2() { return cGroup_2; }

		//instants+=Value
		public Assignment getInstantsAssignment_2_0() { return cInstantsAssignment_2_0; }

		//Value
		public RuleCall getInstantsValueParserRuleCall_2_0_0() { return cInstantsValueParserRuleCall_2_0_0; }

		//("," instants+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }

		//","
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }

		//instants+=Expression
		public Assignment getInstantsAssignment_2_1_1() { return cInstantsAssignment_2_1_1; }

		//Expression
		public RuleCall getInstantsExpressionParserRuleCall_2_1_1_0() { return cInstantsExpressionParserRuleCall_2_1_1_0; }
	}

	public class RelationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Relation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cImplicationRelationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTagRelationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAwaitImplicationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Relation:
		//	ImplicationRelation | TagRelation | AwaitImplication;
		@Override public ParserRule getRule() { return rule; }

		//ImplicationRelation | TagRelation | AwaitImplication
		public Alternatives getAlternatives() { return cAlternatives; }

		//ImplicationRelation
		public RuleCall getImplicationRelationParserRuleCall_0() { return cImplicationRelationParserRuleCall_0; }

		//TagRelation
		public RuleCall getTagRelationParserRuleCall_1() { return cTagRelationParserRuleCall_1; }

		//AwaitImplication
		public RuleCall getAwaitImplicationParserRuleCall_2() { return cAwaitImplicationParserRuleCall_2; }
	}

	public class ImplicationRelationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.ImplicationRelation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSourceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cSourceClockCrossReference_0_0 = (CrossReference)cSourceAssignment_0.eContents().get(0);
		private final RuleCall cSourceClockIDTerminalRuleCall_0_0_1 = (RuleCall)cSourceClockCrossReference_0_0.eContents().get(1);
		private final Assignment cQualAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cQualImplicationQualifierParserRuleCall_1_0 = (RuleCall)cQualAssignment_1.eContents().get(0);
		private final Keyword cImpliesKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTargetAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cTargetClockCrossReference_3_0 = (CrossReference)cTargetAssignment_3.eContents().get(0);
		private final RuleCall cTargetClockIDTerminalRuleCall_3_0_1 = (RuleCall)cTargetClockCrossReference_3_0.eContents().get(1);
		
		//ImplicationRelation:
		//	source=[Clock] qual=ImplicationQualifier? "implies" target=[Clock];
		@Override public ParserRule getRule() { return rule; }

		//source=[Clock] qual=ImplicationQualifier? "implies" target=[Clock]
		public Group getGroup() { return cGroup; }

		//source=[Clock]
		public Assignment getSourceAssignment_0() { return cSourceAssignment_0; }

		//[Clock]
		public CrossReference getSourceClockCrossReference_0_0() { return cSourceClockCrossReference_0_0; }

		//ID
		public RuleCall getSourceClockIDTerminalRuleCall_0_0_1() { return cSourceClockIDTerminalRuleCall_0_0_1; }

		//qual=ImplicationQualifier?
		public Assignment getQualAssignment_1() { return cQualAssignment_1; }

		//ImplicationQualifier
		public RuleCall getQualImplicationQualifierParserRuleCall_1_0() { return cQualImplicationQualifierParserRuleCall_1_0; }

		//"implies"
		public Keyword getImpliesKeyword_2() { return cImpliesKeyword_2; }

		//target=[Clock]
		public Assignment getTargetAssignment_3() { return cTargetAssignment_3; }

		//[Clock]
		public CrossReference getTargetClockCrossReference_3_0() { return cTargetClockCrossReference_3_0; }

		//ID
		public RuleCall getTargetClockIDTerminalRuleCall_3_0_1() { return cTargetClockIDTerminalRuleCall_3_0_1; }
	}

	public class AwaitImplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.AwaitImplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAwaitKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cMastersAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cMastersClockCrossReference_1_0 = (CrossReference)cMastersAssignment_1.eContents().get(0);
		private final RuleCall cMastersClockIDTerminalRuleCall_1_0_1 = (RuleCall)cMastersClockCrossReference_1_0.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cWithKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Alternatives cAlternatives_2_1 = (Alternatives)cGroup_2.eContents().get(1);
		private final Assignment cWeakAssignment_2_1_0 = (Assignment)cAlternatives_2_1.eContents().get(0);
		private final Keyword cWeakWeakKeyword_2_1_0_0 = (Keyword)cWeakAssignment_2_1_0.eContents().get(0);
		private final Assignment cStrongAssignment_2_1_1 = (Assignment)cAlternatives_2_1.eContents().get(1);
		private final Keyword cStrongStrongKeyword_2_1_1_0 = (Keyword)cStrongAssignment_2_1_1.eContents().get(0);
		private final Keyword cResetKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Keyword cOnKeyword_2_3 = (Keyword)cGroup_2.eContents().get(3);
		private final Assignment cResetAssignment_2_4 = (Assignment)cGroup_2.eContents().get(4);
		private final CrossReference cResetClockCrossReference_2_4_0 = (CrossReference)cResetAssignment_2_4.eContents().get(0);
		private final RuleCall cResetClockIDTerminalRuleCall_2_4_0_1 = (RuleCall)cResetClockCrossReference_2_4_0.eContents().get(1);
		private final Keyword cImpliesKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cTargetAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cTargetClockCrossReference_4_0 = (CrossReference)cTargetAssignment_4.eContents().get(0);
		private final RuleCall cTargetClockIDTerminalRuleCall_4_0_1 = (RuleCall)cTargetClockCrossReference_4_0.eContents().get(1);
		
		//AwaitImplication:
		//	"await" masters+=[Clock]+ ("with" (weak?="weak" | strong?="strong") "reset" "on" reset=[Clock])? "implies"
		//	target=[Clock];
		@Override public ParserRule getRule() { return rule; }

		//"await" masters+=[Clock]+ ("with" (weak?="weak" | strong?="strong") "reset" "on" reset=[Clock])? "implies"
		//target=[Clock]
		public Group getGroup() { return cGroup; }

		//"await"
		public Keyword getAwaitKeyword_0() { return cAwaitKeyword_0; }

		//masters+=[Clock]+
		public Assignment getMastersAssignment_1() { return cMastersAssignment_1; }

		//[Clock]
		public CrossReference getMastersClockCrossReference_1_0() { return cMastersClockCrossReference_1_0; }

		//ID
		public RuleCall getMastersClockIDTerminalRuleCall_1_0_1() { return cMastersClockIDTerminalRuleCall_1_0_1; }

		//("with" (weak?="weak" | strong?="strong") "reset" "on" reset=[Clock])?
		public Group getGroup_2() { return cGroup_2; }

		//"with"
		public Keyword getWithKeyword_2_0() { return cWithKeyword_2_0; }

		//(weak?="weak" | strong?="strong")
		public Alternatives getAlternatives_2_1() { return cAlternatives_2_1; }

		//weak?="weak"
		public Assignment getWeakAssignment_2_1_0() { return cWeakAssignment_2_1_0; }

		//"weak"
		public Keyword getWeakWeakKeyword_2_1_0_0() { return cWeakWeakKeyword_2_1_0_0; }

		//strong?="strong"
		public Assignment getStrongAssignment_2_1_1() { return cStrongAssignment_2_1_1; }

		//"strong"
		public Keyword getStrongStrongKeyword_2_1_1_0() { return cStrongStrongKeyword_2_1_1_0; }

		//"reset"
		public Keyword getResetKeyword_2_2() { return cResetKeyword_2_2; }

		//"on"
		public Keyword getOnKeyword_2_3() { return cOnKeyword_2_3; }

		//reset=[Clock]
		public Assignment getResetAssignment_2_4() { return cResetAssignment_2_4; }

		//[Clock]
		public CrossReference getResetClockCrossReference_2_4_0() { return cResetClockCrossReference_2_4_0; }

		//ID
		public RuleCall getResetClockIDTerminalRuleCall_2_4_0_1() { return cResetClockIDTerminalRuleCall_2_4_0_1; }

		//"implies"
		public Keyword getImpliesKeyword_3() { return cImpliesKeyword_3; }

		//target=[Clock]
		public Assignment getTargetAssignment_4() { return cTargetAssignment_4; }

		//[Clock]
		public CrossReference getTargetClockCrossReference_4_0() { return cTargetClockCrossReference_4_0; }

		//ID
		public RuleCall getTargetClockIDTerminalRuleCall_4_0_1() { return cTargetClockIDTerminalRuleCall_4_0_1; }
	}

	public class ImplicationQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.ImplicationQualifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cFilteredQualifierParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEveryQualifierParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDelayedQualifierParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cSustainedQualifierParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cTimeDelayedQualifierParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cWhenQualifierParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cNextQualifierParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		//ImplicationQualifier:
		//	FilteredQualifier | EveryQualifier | DelayedQualifier | SustainedQualifier | TimeDelayedQualifier | WhenQualifier |
		//	NextQualifier;
		@Override public ParserRule getRule() { return rule; }

		//FilteredQualifier | EveryQualifier | DelayedQualifier | SustainedQualifier | TimeDelayedQualifier | WhenQualifier |
		//NextQualifier
		public Alternatives getAlternatives() { return cAlternatives; }

		//FilteredQualifier
		public RuleCall getFilteredQualifierParserRuleCall_0() { return cFilteredQualifierParserRuleCall_0; }

		//EveryQualifier
		public RuleCall getEveryQualifierParserRuleCall_1() { return cEveryQualifierParserRuleCall_1; }

		//DelayedQualifier
		public RuleCall getDelayedQualifierParserRuleCall_2() { return cDelayedQualifierParserRuleCall_2; }

		//SustainedQualifier
		public RuleCall getSustainedQualifierParserRuleCall_3() { return cSustainedQualifierParserRuleCall_3; }

		//TimeDelayedQualifier
		public RuleCall getTimeDelayedQualifierParserRuleCall_4() { return cTimeDelayedQualifierParserRuleCall_4; }

		//WhenQualifier
		public RuleCall getWhenQualifierParserRuleCall_5() { return cWhenQualifierParserRuleCall_5; }

		//NextQualifier
		public RuleCall getNextQualifierParserRuleCall_6() { return cNextQualifierParserRuleCall_6; }
	}

	public class FilteredQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.FilteredQualifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFilteredKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cByKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cPatternAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPatternPatternParserRuleCall_2_0 = (RuleCall)cPatternAssignment_2.eContents().get(0);
		
		//FilteredQualifier:
		//	"filtered" "by" pattern=Pattern;
		@Override public ParserRule getRule() { return rule; }

		//"filtered" "by" pattern=Pattern
		public Group getGroup() { return cGroup; }

		//"filtered"
		public Keyword getFilteredKeyword_0() { return cFilteredKeyword_0; }

		//"by"
		public Keyword getByKeyword_1() { return cByKeyword_1; }

		//pattern=Pattern
		public Assignment getPatternAssignment_2() { return cPatternAssignment_2; }

		//Pattern
		public RuleCall getPatternPatternParserRuleCall_2_0() { return cPatternPatternParserRuleCall_2_0; }
	}

	public class EveryQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.EveryQualifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEveryKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPeriodAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPeriodExpressionParserRuleCall_1_0 = (RuleCall)cPeriodAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cOffAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final Keyword cOffStartingKeyword_2_0_0 = (Keyword)cOffAssignment_2_0.eContents().get(0);
		private final Keyword cAtKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cOffsetAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cOffsetExpressionParserRuleCall_2_2_0 = (RuleCall)cOffsetAssignment_2_2.eContents().get(0);
		
		//EveryQualifier:
		//	"every" period=Expression (off?="starting" "at" offset=Expression)?;
		@Override public ParserRule getRule() { return rule; }

		//"every" period=Expression (off?="starting" "at" offset=Expression)?
		public Group getGroup() { return cGroup; }

		//"every"
		public Keyword getEveryKeyword_0() { return cEveryKeyword_0; }

		//period=Expression
		public Assignment getPeriodAssignment_1() { return cPeriodAssignment_1; }

		//Expression
		public RuleCall getPeriodExpressionParserRuleCall_1_0() { return cPeriodExpressionParserRuleCall_1_0; }

		//(off?="starting" "at" offset=Expression)?
		public Group getGroup_2() { return cGroup_2; }

		//off?="starting"
		public Assignment getOffAssignment_2_0() { return cOffAssignment_2_0; }

		//"starting"
		public Keyword getOffStartingKeyword_2_0_0() { return cOffStartingKeyword_2_0_0; }

		//"at"
		public Keyword getAtKeyword_2_1() { return cAtKeyword_2_1; }

		//offset=Expression
		public Assignment getOffsetAssignment_2_2() { return cOffsetAssignment_2_2; }

		//Expression
		public RuleCall getOffsetExpressionParserRuleCall_2_2_0() { return cOffsetExpressionParserRuleCall_2_2_0; }
	}

	public class DelayedQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.DelayedQualifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImmediatelyAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cImmediatelyImmediatelyKeyword_0_0 = (Keyword)cImmediatelyAssignment_0.eContents().get(0);
		private final Keyword cDelayedKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cByKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCountAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCountExpressionParserRuleCall_3_0 = (RuleCall)cCountAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cResetAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final Keyword cResetWithKeyword_4_0_0 = (Keyword)cResetAssignment_4_0.eContents().get(0);
		private final Keyword cResetKeyword_4_1 = (Keyword)cGroup_4.eContents().get(1);
		private final Keyword cOnKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cClockAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final CrossReference cClockClockCrossReference_6_0 = (CrossReference)cClockAssignment_6.eContents().get(0);
		private final RuleCall cClockClockIDTerminalRuleCall_6_0_1 = (RuleCall)cClockClockCrossReference_6_0.eContents().get(1);
		
		//DelayedQualifier:
		//	immediately?="immediately"? "delayed" "by" count=Expression (reset?="with" "reset")? "on" clock=[Clock];
		@Override public ParserRule getRule() { return rule; }

		//immediately?="immediately"? "delayed" "by" count=Expression (reset?="with" "reset")? "on" clock=[Clock]
		public Group getGroup() { return cGroup; }

		//immediately?="immediately"?
		public Assignment getImmediatelyAssignment_0() { return cImmediatelyAssignment_0; }

		//"immediately"
		public Keyword getImmediatelyImmediatelyKeyword_0_0() { return cImmediatelyImmediatelyKeyword_0_0; }

		//"delayed"
		public Keyword getDelayedKeyword_1() { return cDelayedKeyword_1; }

		//"by"
		public Keyword getByKeyword_2() { return cByKeyword_2; }

		//count=Expression
		public Assignment getCountAssignment_3() { return cCountAssignment_3; }

		//Expression
		public RuleCall getCountExpressionParserRuleCall_3_0() { return cCountExpressionParserRuleCall_3_0; }

		//(reset?="with" "reset")?
		public Group getGroup_4() { return cGroup_4; }

		//reset?="with"
		public Assignment getResetAssignment_4_0() { return cResetAssignment_4_0; }

		//"with"
		public Keyword getResetWithKeyword_4_0_0() { return cResetWithKeyword_4_0_0; }

		//"reset"
		public Keyword getResetKeyword_4_1() { return cResetKeyword_4_1; }

		//"on"
		public Keyword getOnKeyword_5() { return cOnKeyword_5; }

		//clock=[Clock]
		public Assignment getClockAssignment_6() { return cClockAssignment_6; }

		//[Clock]
		public CrossReference getClockClockCrossReference_6_0() { return cClockClockCrossReference_6_0; }

		//ID
		public RuleCall getClockClockIDTerminalRuleCall_6_0_1() { return cClockClockIDTerminalRuleCall_6_0_1; }
	}

	public class SustainedQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.SustainedQualifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSustainedKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cImmediatelyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cImmediatelyImmediatelyKeyword_1_0 = (Keyword)cImmediatelyAssignment_1.eContents().get(0);
		private final Keyword cFromKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cStartClockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cStartClockClockCrossReference_3_0 = (CrossReference)cStartClockAssignment_3.eContents().get(0);
		private final RuleCall cStartClockClockIDTerminalRuleCall_3_0_1 = (RuleCall)cStartClockClockCrossReference_3_0.eContents().get(1);
		private final Keyword cToKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cEndClockAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cEndClockClockCrossReference_5_0 = (CrossReference)cEndClockAssignment_5.eContents().get(0);
		private final RuleCall cEndClockClockIDTerminalRuleCall_5_0_1 = (RuleCall)cEndClockClockCrossReference_5_0.eContents().get(1);
		private final Assignment cWeaklyAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final Keyword cWeaklyWeaklyKeyword_6_0 = (Keyword)cWeaklyAssignment_6.eContents().get(0);
		
		//SustainedQualifier:
		//	"sustained" immediately?="immediately"?
		//	"from" startClock=[Clock] "to" endClock=[Clock] weakly?="weakly"?;
		@Override public ParserRule getRule() { return rule; }

		//"sustained" immediately?="immediately"? "from" startClock=[Clock] "to" endClock=[Clock] weakly?="weakly"?
		public Group getGroup() { return cGroup; }

		//"sustained"
		public Keyword getSustainedKeyword_0() { return cSustainedKeyword_0; }

		//immediately?="immediately"?
		public Assignment getImmediatelyAssignment_1() { return cImmediatelyAssignment_1; }

		//"immediately"
		public Keyword getImmediatelyImmediatelyKeyword_1_0() { return cImmediatelyImmediatelyKeyword_1_0; }

		//"from"
		public Keyword getFromKeyword_2() { return cFromKeyword_2; }

		//startClock=[Clock]
		public Assignment getStartClockAssignment_3() { return cStartClockAssignment_3; }

		//[Clock]
		public CrossReference getStartClockClockCrossReference_3_0() { return cStartClockClockCrossReference_3_0; }

		//ID
		public RuleCall getStartClockClockIDTerminalRuleCall_3_0_1() { return cStartClockClockIDTerminalRuleCall_3_0_1; }

		//"to"
		public Keyword getToKeyword_4() { return cToKeyword_4; }

		//endClock=[Clock]
		public Assignment getEndClockAssignment_5() { return cEndClockAssignment_5; }

		//[Clock]
		public CrossReference getEndClockClockCrossReference_5_0() { return cEndClockClockCrossReference_5_0; }

		//ID
		public RuleCall getEndClockClockIDTerminalRuleCall_5_0_1() { return cEndClockClockIDTerminalRuleCall_5_0_1; }

		//weakly?="weakly"?
		public Assignment getWeaklyAssignment_6() { return cWeaklyAssignment_6; }

		//"weakly"
		public Keyword getWeaklyWeaklyKeyword_6_0() { return cWeaklyWeaklyKeyword_6_0; }
	}

	public class TimeDelayedQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.TimeDelayedQualifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTimeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cDelayedKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cByKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cDelayAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cDelayExpressionParserRuleCall_3_0 = (RuleCall)cDelayAssignment_3.eContents().get(0);
		private final Keyword cOnKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cClockAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final CrossReference cClockClockCrossReference_5_0 = (CrossReference)cClockAssignment_5.eContents().get(0);
		private final RuleCall cClockClockIDTerminalRuleCall_5_0_1 = (RuleCall)cClockClockCrossReference_5_0.eContents().get(1);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Assignment cResetAssignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final Keyword cResetWithKeyword_6_0_0 = (Keyword)cResetAssignment_6_0.eContents().get(0);
		private final UnorderedGroup cUnorderedGroup_6_1 = (UnorderedGroup)cGroup_6.eContents().get(1);
		private final Assignment cImmResetAssignment_6_1_0 = (Assignment)cUnorderedGroup_6_1.eContents().get(0);
		private final Keyword cImmResetImmediateKeyword_6_1_0_0 = (Keyword)cImmResetAssignment_6_1_0.eContents().get(0);
		private final Assignment cStrongResetAssignment_6_1_1 = (Assignment)cUnorderedGroup_6_1.eContents().get(1);
		private final Keyword cStrongResetStrongKeyword_6_1_1_0 = (Keyword)cStrongResetAssignment_6_1_1.eContents().get(0);
		private final Keyword cResetKeyword_6_2 = (Keyword)cGroup_6.eContents().get(2);
		private final Keyword cOnKeyword_6_3 = (Keyword)cGroup_6.eContents().get(3);
		private final Assignment cResetClockAssignment_6_4 = (Assignment)cGroup_6.eContents().get(4);
		private final CrossReference cResetClockClockCrossReference_6_4_0 = (CrossReference)cResetClockAssignment_6_4.eContents().get(0);
		private final RuleCall cResetClockClockIDTerminalRuleCall_6_4_0_1 = (RuleCall)cResetClockClockCrossReference_6_4_0.eContents().get(1);
		
		//TimeDelayedQualifier:
		//	"time" "delayed" "by" delay=Expression "on" clock=[Clock] (reset?="with" (immReset?="immediate"? &
		//	strongReset?="strong"?) "reset" "on" resetClock=[Clock])?
		//	//timeExpr=Expr
		//;
		@Override public ParserRule getRule() { return rule; }

		//"time" "delayed" "by" delay=Expression "on" clock=[Clock] (reset?="with" (immReset?="immediate"? &
		//strongReset?="strong"?) "reset" "on" resetClock=[Clock])?
		public Group getGroup() { return cGroup; }

		//"time"
		public Keyword getTimeKeyword_0() { return cTimeKeyword_0; }

		//"delayed"
		public Keyword getDelayedKeyword_1() { return cDelayedKeyword_1; }

		//"by"
		public Keyword getByKeyword_2() { return cByKeyword_2; }

		//delay=Expression
		public Assignment getDelayAssignment_3() { return cDelayAssignment_3; }

		//Expression
		public RuleCall getDelayExpressionParserRuleCall_3_0() { return cDelayExpressionParserRuleCall_3_0; }

		//"on"
		public Keyword getOnKeyword_4() { return cOnKeyword_4; }

		//clock=[Clock]
		public Assignment getClockAssignment_5() { return cClockAssignment_5; }

		//[Clock]
		public CrossReference getClockClockCrossReference_5_0() { return cClockClockCrossReference_5_0; }

		//ID
		public RuleCall getClockClockIDTerminalRuleCall_5_0_1() { return cClockClockIDTerminalRuleCall_5_0_1; }

		//(reset?="with" (immReset?="immediate"? & strongReset?="strong"?) "reset" "on" resetClock=[Clock])?
		public Group getGroup_6() { return cGroup_6; }

		//reset?="with"
		public Assignment getResetAssignment_6_0() { return cResetAssignment_6_0; }

		//"with"
		public Keyword getResetWithKeyword_6_0_0() { return cResetWithKeyword_6_0_0; }

		//(immReset?="immediate"? & strongReset?="strong"?)
		public UnorderedGroup getUnorderedGroup_6_1() { return cUnorderedGroup_6_1; }

		//immReset?="immediate"?
		public Assignment getImmResetAssignment_6_1_0() { return cImmResetAssignment_6_1_0; }

		//"immediate"
		public Keyword getImmResetImmediateKeyword_6_1_0_0() { return cImmResetImmediateKeyword_6_1_0_0; }

		//strongReset?="strong"?
		public Assignment getStrongResetAssignment_6_1_1() { return cStrongResetAssignment_6_1_1; }

		//"strong"
		public Keyword getStrongResetStrongKeyword_6_1_1_0() { return cStrongResetStrongKeyword_6_1_1_0; }

		//"reset"
		public Keyword getResetKeyword_6_2() { return cResetKeyword_6_2; }

		//"on"
		public Keyword getOnKeyword_6_3() { return cOnKeyword_6_3; }

		//resetClock=[Clock]
		public Assignment getResetClockAssignment_6_4() { return cResetClockAssignment_6_4; }

		//[Clock]
		public CrossReference getResetClockClockCrossReference_6_4_0() { return cResetClockClockCrossReference_6_4_0; }

		//ID
		public RuleCall getResetClockClockIDTerminalRuleCall_6_4_0_1() { return cResetClockClockIDTerminalRuleCall_6_4_0_1; }
	}

	public class LetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Let");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLetKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeValueTypeEnumRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIDTerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cValueAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cValueExpressionParserRuleCall_4_0 = (RuleCall)cValueAssignment_4.eContents().get(0);
		
		//Let:
		//	"let" type=ValueType name=ID "=" value=Expression;
		@Override public ParserRule getRule() { return rule; }

		//"let" type=ValueType name=ID "=" value=Expression
		public Group getGroup() { return cGroup; }

		//"let"
		public Keyword getLetKeyword_0() { return cLetKeyword_0; }

		//type=ValueType
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }

		//ValueType
		public RuleCall getTypeValueTypeEnumRuleCall_1_0() { return cTypeValueTypeEnumRuleCall_1_0; }

		//name=ID
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }

		//ID
		public RuleCall getNameIDTerminalRuleCall_2_0() { return cNameIDTerminalRuleCall_2_0; }

		//"="
		public Keyword getEqualsSignKeyword_3() { return cEqualsSignKeyword_3; }

		//value=Expression
		public Assignment getValueAssignment_4() { return cValueAssignment_4; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_4_0() { return cValueExpressionParserRuleCall_4_0; }
	}

	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntegerValueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDecimalValueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFloatValueParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cRationalValueParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cLetValueParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Value:
		//	IntegerValue | DecimalValue | FloatValue | RationalValue | LetValue;
		@Override public ParserRule getRule() { return rule; }

		//IntegerValue | DecimalValue | FloatValue | RationalValue | LetValue
		public Alternatives getAlternatives() { return cAlternatives; }

		//IntegerValue
		public RuleCall getIntegerValueParserRuleCall_0() { return cIntegerValueParserRuleCall_0; }

		//DecimalValue
		public RuleCall getDecimalValueParserRuleCall_1() { return cDecimalValueParserRuleCall_1; }

		//FloatValue
		public RuleCall getFloatValueParserRuleCall_2() { return cFloatValueParserRuleCall_2; }

		//RationalValue
		public RuleCall getRationalValueParserRuleCall_3() { return cRationalValueParserRuleCall_3; }

		//LetValue
		public RuleCall getLetValueParserRuleCall_4() { return cLetValueParserRuleCall_4; }
	}

	public class IntegerValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.IntegerValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSignAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSignOpTermEnumRuleCall_0_0 = (RuleCall)cSignAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueBIG_INTTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//IntegerValue:
		//	sign=OpTerm? value=BIG_INT;
		@Override public ParserRule getRule() { return rule; }

		//sign=OpTerm? value=BIG_INT
		public Group getGroup() { return cGroup; }

		//sign=OpTerm?
		public Assignment getSignAssignment_0() { return cSignAssignment_0; }

		//OpTerm
		public RuleCall getSignOpTermEnumRuleCall_0_0() { return cSignOpTermEnumRuleCall_0_0; }

		//value=BIG_INT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//BIG_INT
		public RuleCall getValueBIG_INTTerminalRuleCall_1_0() { return cValueBIG_INTTerminalRuleCall_1_0; }
	}

	public class DecimalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.DecimalValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSignAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSignOpTermEnumRuleCall_0_0 = (RuleCall)cSignAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueBIG_DECIMALTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//DecimalValue:
		//	sign=OpTerm? value=BIG_DECIMAL;
		@Override public ParserRule getRule() { return rule; }

		//sign=OpTerm? value=BIG_DECIMAL
		public Group getGroup() { return cGroup; }

		//sign=OpTerm?
		public Assignment getSignAssignment_0() { return cSignAssignment_0; }

		//OpTerm
		public RuleCall getSignOpTermEnumRuleCall_0_0() { return cSignOpTermEnumRuleCall_0_0; }

		//value=BIG_DECIMAL
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//BIG_DECIMAL
		public RuleCall getValueBIG_DECIMALTerminalRuleCall_1_0() { return cValueBIG_DECIMALTerminalRuleCall_1_0; }
	}

	public class FloatValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.FloatValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSignAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSignOpTermEnumRuleCall_0_0 = (RuleCall)cSignAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueFLOATTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//FloatValue:
		//	sign=OpTerm? value=FLOAT;
		@Override public ParserRule getRule() { return rule; }

		//sign=OpTerm? value=FLOAT
		public Group getGroup() { return cGroup; }

		//sign=OpTerm?
		public Assignment getSignAssignment_0() { return cSignAssignment_0; }

		//OpTerm
		public RuleCall getSignOpTermEnumRuleCall_0_0() { return cSignOpTermEnumRuleCall_0_0; }

		//value=FLOAT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//FLOAT
		public RuleCall getValueFLOATTerminalRuleCall_1_0() { return cValueFLOATTerminalRuleCall_1_0; }
	}

	public class RationalValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.RationalValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSignAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSignOpTermEnumRuleCall_0_0 = (RuleCall)cSignAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueRATIONALTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//RationalValue:
		//	sign=OpTerm? value=RATIONAL;
		@Override public ParserRule getRule() { return rule; }

		//sign=OpTerm? value=RATIONAL
		public Group getGroup() { return cGroup; }

		//sign=OpTerm?
		public Assignment getSignAssignment_0() { return cSignAssignment_0; }

		//OpTerm
		public RuleCall getSignOpTermEnumRuleCall_0_0() { return cSignOpTermEnumRuleCall_0_0; }

		//value=RATIONAL
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//RATIONAL
		public RuleCall getValueRATIONALTerminalRuleCall_1_0() { return cValueRATIONALTerminalRuleCall_1_0; }
	}

	public class LetValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.LetValue");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDollarSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRefAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cRefLetCrossReference_1_0 = (CrossReference)cRefAssignment_1.eContents().get(0);
		private final RuleCall cRefLetIDTerminalRuleCall_1_0_1 = (RuleCall)cRefLetCrossReference_1_0.eContents().get(1);
		
		//LetValue:
		//	"$" ref=[Let];
		@Override public ParserRule getRule() { return rule; }

		//"$" ref=[Let]
		public Group getGroup() { return cGroup; }

		//"$"
		public Keyword getDollarSignKeyword_0() { return cDollarSignKeyword_0; }

		//ref=[Let]
		public Assignment getRefAssignment_1() { return cRefAssignment_1; }

		//[Let]
		public CrossReference getRefLetCrossReference_1_0() { return cRefLetCrossReference_1_0; }

		//ID
		public RuleCall getRefLetIDTerminalRuleCall_1_0_1() { return cRefLetIDTerminalRuleCall_1_0_1; }
	}

	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Expression");
		private final RuleCall cTermParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Expression:
		//	Term;
		@Override public ParserRule getRule() { return rule; }

		//Term
		public RuleCall getTermParserRuleCall() { return cTermParserRuleCall; }
	}

	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Term");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFactorParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinOpLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpOpTermEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightFactorParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Term Expression:
		//	Factor ({BinOp.left=current} op=OpTerm right=Factor)*;
		@Override public ParserRule getRule() { return rule; }

		//Factor ({BinOp.left=current} op=OpTerm right=Factor)*
		public Group getGroup() { return cGroup; }

		//Factor
		public RuleCall getFactorParserRuleCall_0() { return cFactorParserRuleCall_0; }

		//({BinOp.left=current} op=OpTerm right=Factor)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinOp.left=current}
		public Action getBinOpLeftAction_1_0() { return cBinOpLeftAction_1_0; }

		//op=OpTerm
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//OpTerm
		public RuleCall getOpOpTermEnumRuleCall_1_1_0() { return cOpOpTermEnumRuleCall_1_1_0; }

		//right=Factor
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//Factor
		public RuleCall getRightFactorParserRuleCall_1_2_0() { return cRightFactorParserRuleCall_1_2_0; }
	}

	public class FactorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Factor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBasicExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBinOpLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOpOpFactEnumRuleCall_1_1_0 = (RuleCall)cOpAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBasicExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//Factor Expression:
		//	BasicExpr ({BinOp.left=current} op=OpFact right=BasicExpr)*;
		@Override public ParserRule getRule() { return rule; }

		//BasicExpr ({BinOp.left=current} op=OpFact right=BasicExpr)*
		public Group getGroup() { return cGroup; }

		//BasicExpr
		public RuleCall getBasicExprParserRuleCall_0() { return cBasicExprParserRuleCall_0; }

		//({BinOp.left=current} op=OpFact right=BasicExpr)*
		public Group getGroup_1() { return cGroup_1; }

		//{BinOp.left=current}
		public Action getBinOpLeftAction_1_0() { return cBinOpLeftAction_1_0; }

		//op=OpFact
		public Assignment getOpAssignment_1_1() { return cOpAssignment_1_1; }

		//OpFact
		public RuleCall getOpOpFactEnumRuleCall_1_1_0() { return cOpOpFactEnumRuleCall_1_1_0; }

		//right=BasicExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//BasicExpr
		public RuleCall getRightBasicExprParserRuleCall_1_2_0() { return cRightBasicExprParserRuleCall_1_2_0; }
	}

	public class BasicExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.BasicExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cValueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cExpressionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		private final RuleCall cCastParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//BasicExpr Expression:
		//	Value | '(' Expression ')' | Cast;
		@Override public ParserRule getRule() { return rule; }

		//Value | '(' Expression ')' | Cast
		public Alternatives getAlternatives() { return cAlternatives; }

		//Value
		public RuleCall getValueParserRuleCall_0() { return cValueParserRuleCall_0; }

		//'(' Expression ')'
		public Group getGroup_1() { return cGroup_1; }

		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//Expression
		public RuleCall getExpressionParserRuleCall_1_1() { return cExpressionParserRuleCall_1_1; }

		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }

		//Cast
		public RuleCall getCastParserRuleCall_2() { return cCastParserRuleCall_2; }
	}

	public class CastElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Cast");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntCastParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDecimalCastParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFloatCastParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cRationalCastParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Cast:
		//	IntCast | DecimalCast | FloatCast | RationalCast;
		@Override public ParserRule getRule() { return rule; }

		//IntCast | DecimalCast | FloatCast | RationalCast
		public Alternatives getAlternatives() { return cAlternatives; }

		//IntCast
		public RuleCall getIntCastParserRuleCall_0() { return cIntCastParserRuleCall_0; }

		//DecimalCast
		public RuleCall getDecimalCastParserRuleCall_1() { return cDecimalCastParserRuleCall_1; }

		//FloatCast
		public RuleCall getFloatCastParserRuleCall_2() { return cFloatCastParserRuleCall_2; }

		//RationalCast
		public RuleCall getRationalCastParserRuleCall_3() { return cRationalCastParserRuleCall_3; }
	}

	public class IntCastElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.IntCast");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cIntKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//IntCast:
		//	"[int " expr=Expression "]";
		@Override public ParserRule getRule() { return rule; }

		//"[int " expr=Expression "]"
		public Group getGroup() { return cGroup; }

		//"[int "
		public Keyword getIntKeyword_0() { return cIntKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class FloatCastElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.FloatCast");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cFloatKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cDoubleKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//FloatCast:
		//	("[float " | "[double") expr=Expression "]";
		@Override public ParserRule getRule() { return rule; }

		//("[float " | "[double") expr=Expression "]"
		public Group getGroup() { return cGroup; }

		//("[float " | "[double")
		public Alternatives getAlternatives_0() { return cAlternatives_0; }

		//"[float "
		public Keyword getFloatKeyword_0_0() { return cFloatKeyword_0_0; }

		//"[double"
		public Keyword getDoubleKeyword_0_1() { return cDoubleKeyword_0_1; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class DecimalCastElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.DecimalCast");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDecimalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//DecimalCast:
		//	"[decimal" expr=Expression "]";
		@Override public ParserRule getRule() { return rule; }

		//"[decimal" expr=Expression "]"
		public Group getGroup() { return cGroup; }

		//"[decimal"
		public Keyword getDecimalKeyword_0() { return cDecimalKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class RationalCastElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.RationalCast");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRationalKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExprAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExprExpressionParserRuleCall_1_0 = (RuleCall)cExprAssignment_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//RationalCast:
		//	"[rational " expr=Expression "]";
		@Override public ParserRule getRule() { return rule; }

		//"[rational " expr=Expression "]"
		public Group getGroup() { return cGroup; }

		//"[rational "
		public Keyword getRationalKeyword_0() { return cRationalKeyword_0; }

		//expr=Expression
		public Assignment getExprAssignment_1() { return cExprAssignment_1; }

		//Expression
		public RuleCall getExprExpressionParserRuleCall_1_0() { return cExprExpressionParserRuleCall_1_0; }

		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
	}

	public class WhenQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.WhenQualifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNotAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cNotNotKeyword_1_0 = (Keyword)cNotAssignment_1.eContents().get(0);
		private final Assignment cClockAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cClockClockCrossReference_2_0 = (CrossReference)cClockAssignment_2.eContents().get(0);
		private final RuleCall cClockClockIDTerminalRuleCall_2_0_1 = (RuleCall)cClockClockCrossReference_2_0.eContents().get(1);
		
		//WhenQualifier:
		//	"when" not?="not"? clock=[Clock];
		@Override public ParserRule getRule() { return rule; }

		//"when" not?="not"? clock=[Clock]
		public Group getGroup() { return cGroup; }

		//"when"
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }

		//not?="not"?
		public Assignment getNotAssignment_1() { return cNotAssignment_1; }

		//"not"
		public Keyword getNotNotKeyword_1_0() { return cNotNotKeyword_1_0; }

		//clock=[Clock]
		public Assignment getClockAssignment_2() { return cClockAssignment_2; }

		//[Clock]
		public CrossReference getClockClockCrossReference_2_0() { return cClockClockCrossReference_2_0; }

		//ID
		public RuleCall getClockClockIDTerminalRuleCall_2_0_1() { return cClockClockIDTerminalRuleCall_2_0_1; }
	}

	public class NextQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.NextQualifier");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStrictAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cStrictStrictlyKeyword_0_0 = (Keyword)cStrictAssignment_0.eContents().get(0);
		private final Keyword cNextKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cToKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cClockAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cClockClockCrossReference_3_0 = (CrossReference)cClockAssignment_3.eContents().get(0);
		private final RuleCall cClockClockIDTerminalRuleCall_3_0_1 = (RuleCall)cClockClockCrossReference_3_0.eContents().get(1);
		
		//NextQualifier:
		//	strict?="strictly"? "next" "to" clock=[Clock];
		@Override public ParserRule getRule() { return rule; }

		//strict?="strictly"? "next" "to" clock=[Clock]
		public Group getGroup() { return cGroup; }

		//strict?="strictly"?
		public Assignment getStrictAssignment_0() { return cStrictAssignment_0; }

		//"strictly"
		public Keyword getStrictStrictlyKeyword_0_0() { return cStrictStrictlyKeyword_0_0; }

		//"next"
		public Keyword getNextKeyword_1() { return cNextKeyword_1; }

		//"to"
		public Keyword getToKeyword_2() { return cToKeyword_2; }

		//clock=[Clock]
		public Assignment getClockAssignment_3() { return cClockAssignment_3; }

		//[Clock]
		public CrossReference getClockClockCrossReference_3_0() { return cClockClockCrossReference_3_0; }

		//ID
		public RuleCall getClockClockIDTerminalRuleCall_3_0_1() { return cClockClockIDTerminalRuleCall_3_0_1; }
	}

	public class PatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Pattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSkipAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSkipExpressionParserRuleCall_0_0 = (RuleCall)cSkipAssignment_0.eContents().get(0);
		private final Keyword cCommaKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cKeepAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cKeepExpressionParserRuleCall_2_0 = (RuleCall)cKeepAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cRepAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final Keyword cRepLeftParenthesisKeyword_3_0_0 = (Keyword)cRepAssignment_3_0.eContents().get(0);
		private final Assignment cRepskipAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cRepskipExpressionParserRuleCall_3_1_0 = (RuleCall)cRepskipAssignment_3_1.eContents().get(0);
		private final Keyword cCommaKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Assignment cRepkeepAssignment_3_3 = (Assignment)cGroup_3.eContents().get(3);
		private final RuleCall cRepkeepExpressionParserRuleCall_3_3_0 = (RuleCall)cRepkeepAssignment_3_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_4 = (Keyword)cGroup_3.eContents().get(4);
		private final Keyword cAsteriskKeyword_3_5 = (Keyword)cGroup_3.eContents().get(5);
		
		//Pattern:
		//	skip=Expression "," keep=Expression (rep?="(" repskip=Expression "," repkeep=Expression ")" "*")?;
		@Override public ParserRule getRule() { return rule; }

		//skip=Expression "," keep=Expression (rep?="(" repskip=Expression "," repkeep=Expression ")" "*")?
		public Group getGroup() { return cGroup; }

		//skip=Expression
		public Assignment getSkipAssignment_0() { return cSkipAssignment_0; }

		//Expression
		public RuleCall getSkipExpressionParserRuleCall_0_0() { return cSkipExpressionParserRuleCall_0_0; }

		//","
		public Keyword getCommaKeyword_1() { return cCommaKeyword_1; }

		//keep=Expression
		public Assignment getKeepAssignment_2() { return cKeepAssignment_2; }

		//Expression
		public RuleCall getKeepExpressionParserRuleCall_2_0() { return cKeepExpressionParserRuleCall_2_0; }

		//(rep?="(" repskip=Expression "," repkeep=Expression ")" "*")?
		public Group getGroup_3() { return cGroup_3; }

		//rep?="("
		public Assignment getRepAssignment_3_0() { return cRepAssignment_3_0; }

		//"("
		public Keyword getRepLeftParenthesisKeyword_3_0_0() { return cRepLeftParenthesisKeyword_3_0_0; }

		//repskip=Expression
		public Assignment getRepskipAssignment_3_1() { return cRepskipAssignment_3_1; }

		//Expression
		public RuleCall getRepskipExpressionParserRuleCall_3_1_0() { return cRepskipExpressionParserRuleCall_3_1_0; }

		//","
		public Keyword getCommaKeyword_3_2() { return cCommaKeyword_3_2; }

		//repkeep=Expression
		public Assignment getRepkeepAssignment_3_3() { return cRepkeepAssignment_3_3; }

		//Expression
		public RuleCall getRepkeepExpressionParserRuleCall_3_3_0() { return cRepkeepExpressionParserRuleCall_3_3_0; }

		//")"
		public Keyword getRightParenthesisKeyword_3_4() { return cRightParenthesisKeyword_3_4; }

		//"*"
		public Keyword getAsteriskKeyword_3_5() { return cAsteriskKeyword_3_5; }
	}

	public class TagRelationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.TagRelation");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cTagKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cRelationKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cExprAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cExprTagExprParserRuleCall_0_2_0 = (RuleCall)cExprAssignment_0_2.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cTimeKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cRelationKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExprAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExprTagExprParserRuleCall_1_2_0 = (RuleCall)cExprAssignment_1_2.eContents().get(0);
		
		//TagRelation:
		//	"tag" "relation" expr=TagExpr
		//	| "time" "relation" expr=TagExpr;
		@Override public ParserRule getRule() { return rule; }

		//"tag" "relation" expr=TagExpr | "time" "relation" expr=TagExpr
		public Alternatives getAlternatives() { return cAlternatives; }

		//"tag" "relation" expr=TagExpr
		public Group getGroup_0() { return cGroup_0; }

		//"tag"
		public Keyword getTagKeyword_0_0() { return cTagKeyword_0_0; }

		//"relation"
		public Keyword getRelationKeyword_0_1() { return cRelationKeyword_0_1; }

		//expr=TagExpr
		public Assignment getExprAssignment_0_2() { return cExprAssignment_0_2; }

		//TagExpr
		public RuleCall getExprTagExprParserRuleCall_0_2_0() { return cExprTagExprParserRuleCall_0_2_0; }

		//"time" "relation" expr=TagExpr
		public Group getGroup_1() { return cGroup_1; }

		//"time"
		public Keyword getTimeKeyword_1_0() { return cTimeKeyword_1_0; }

		//"relation"
		public Keyword getRelationKeyword_1_1() { return cRelationKeyword_1_1; }

		//expr=TagExpr
		public Assignment getExprAssignment_1_2() { return cExprAssignment_1_2; }

		//TagExpr
		public RuleCall getExprTagExprParserRuleCall_1_2_0() { return cExprTagExprParserRuleCall_1_2_0; }
	}

	public class TagExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.TagExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTagExprAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cClockYAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cClockYClockCrossReference_1_0 = (CrossReference)cClockYAssignment_1.eContents().get(0);
		private final RuleCall cClockYClockIDTerminalRuleCall_1_0_1 = (RuleCall)cClockYClockCrossReference_1_0.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cValueAAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cValueAExpressionParserRuleCall_3_0_0 = (RuleCall)cValueAAssignment_3_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_3_1 = (Keyword)cGroup_3.eContents().get(1);
		private final Assignment cClockXAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final CrossReference cClockXClockCrossReference_4_0 = (CrossReference)cClockXAssignment_4.eContents().get(0);
		private final RuleCall cClockXClockIDTerminalRuleCall_4_0_1 = (RuleCall)cClockXClockCrossReference_4_0.eContents().get(1);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Keyword cCircumflexAccentKeyword_5_0 = (Keyword)cGroup_5.eContents().get(0);
		private final Assignment cValueNAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cValueNBasicExprParserRuleCall_5_1_0 = (RuleCall)cValueNAssignment_5_1.eContents().get(0);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Keyword cPlusSignKeyword_6_0 = (Keyword)cGroup_6.eContents().get(0);
		private final Assignment cValueBAssignment_6_1 = (Assignment)cGroup_6.eContents().get(1);
		private final RuleCall cValueBExpressionParserRuleCall_6_1_0 = (RuleCall)cValueBAssignment_6_1.eContents().get(0);
		
		//TagExpr:
		//	{TagExpr} clockY=[Clock] "=" (valueA=Expression "*")? clockX=[Clock] ("^" valueN=BasicExpr)? ("+" valueB=Expression)?;
		@Override public ParserRule getRule() { return rule; }

		//{TagExpr} clockY=[Clock] "=" (valueA=Expression "*")? clockX=[Clock] ("^" valueN=BasicExpr)? ("+" valueB=Expression)?
		public Group getGroup() { return cGroup; }

		//{TagExpr}
		public Action getTagExprAction_0() { return cTagExprAction_0; }

		//clockY=[Clock]
		public Assignment getClockYAssignment_1() { return cClockYAssignment_1; }

		//[Clock]
		public CrossReference getClockYClockCrossReference_1_0() { return cClockYClockCrossReference_1_0; }

		//ID
		public RuleCall getClockYClockIDTerminalRuleCall_1_0_1() { return cClockYClockIDTerminalRuleCall_1_0_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//(valueA=Expression "*")?
		public Group getGroup_3() { return cGroup_3; }

		//valueA=Expression
		public Assignment getValueAAssignment_3_0() { return cValueAAssignment_3_0; }

		//Expression
		public RuleCall getValueAExpressionParserRuleCall_3_0_0() { return cValueAExpressionParserRuleCall_3_0_0; }

		//"*"
		public Keyword getAsteriskKeyword_3_1() { return cAsteriskKeyword_3_1; }

		//clockX=[Clock]
		public Assignment getClockXAssignment_4() { return cClockXAssignment_4; }

		//[Clock]
		public CrossReference getClockXClockCrossReference_4_0() { return cClockXClockCrossReference_4_0; }

		//ID
		public RuleCall getClockXClockIDTerminalRuleCall_4_0_1() { return cClockXClockIDTerminalRuleCall_4_0_1; }

		//("^" valueN=BasicExpr)?
		public Group getGroup_5() { return cGroup_5; }

		//"^"
		public Keyword getCircumflexAccentKeyword_5_0() { return cCircumflexAccentKeyword_5_0; }

		//valueN=BasicExpr
		public Assignment getValueNAssignment_5_1() { return cValueNAssignment_5_1; }

		//BasicExpr
		public RuleCall getValueNBasicExprParserRuleCall_5_1_0() { return cValueNBasicExprParserRuleCall_5_1_0; }

		//("+" valueB=Expression)?
		public Group getGroup_6() { return cGroup_6; }

		//"+"
		public Keyword getPlusSignKeyword_6_0() { return cPlusSignKeyword_6_0; }

		//valueB=Expression
		public Assignment getValueBAssignment_6_1() { return cValueBAssignment_6_1; }

		//Expression
		public RuleCall getValueBExpressionParserRuleCall_6_1_0() { return cValueBExpressionParserRuleCall_6_1_0; }
	}

	public class PragmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Pragma");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cStopPragmaParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTagrefPragmaParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTracePragmaParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cMaxstepPragmaParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cOutputPragmaParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cDoubleCalcPragmaParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cDumpResultPragmaParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		
		///*
		//TagExpr:
		//	SameTagsExpr | AffineTagsExpr | PowerTagExpr
		//;
		//
		//SameTagsExpr:
		//	{SameTagsExpr} clockY=[Clock | ID] eq="=" clockX=[Clock | ID]
		//;
		//
		//AffineTagsExpr:
		//	{AffineTagsExpr} clockY=[Clock | ID] eq="=" valueA=Expression "*" clockX=[Clock | ID] ("+" valueB=Expression)?
		//|	{AffineTagsExpr} clockY=[Clock | ID] eq="=" clockX=[Clock | ID] "+" valueB=Expression
		//;
		//
		//PowerTagExpr:
		//	{PowerTagExpr} clockY=[Clock | ID] eq="=" (valueA=BasicExpr "*")? clockX=[Clock | ID] "^" valueN=BasicExpr "+" valueB=Expression
		//;
		//*/ /*
		//TagEq:
		//	clock=[Clock | ID] "=" expr=Expr
		//;
		//
		///*
		//BinOp1:
		//	'*' | '/'
		//;
		//
		//BinOp2:
		//	'+' | '-'
		//;
		//
		//
		//Expr:
		//	Term ({BinOperation.left=current} operator=BinOp2 right=Term)*
		//;
		//
		//Term returns Expr:
		//	Factor ({BinOperation.left=current} operator=BinOp1 right=Factor)*
		//;
		//
		//Factor returns Expr:
		//	{ClockRef} clock=[Clock | ID] |
		//	{Litteral} value=Value |
		//	( '(' Expr ')' )
		//;
		//*/ Pragma:
		//	StopPragma | TagrefPragma | TracePragma | MaxstepPragma
		//	| OutputPragma | DoubleCalcPragma | DumpResultPragma;
		@Override public ParserRule getRule() { return rule; }

		//StopPragma | TagrefPragma | TracePragma | MaxstepPragma | OutputPragma | DoubleCalcPragma | DumpResultPragma
		public Alternatives getAlternatives() { return cAlternatives; }

		//StopPragma
		public RuleCall getStopPragmaParserRuleCall_0() { return cStopPragmaParserRuleCall_0; }

		//TagrefPragma
		public RuleCall getTagrefPragmaParserRuleCall_1() { return cTagrefPragmaParserRuleCall_1; }

		//TracePragma
		public RuleCall getTracePragmaParserRuleCall_2() { return cTracePragmaParserRuleCall_2; }

		//MaxstepPragma
		public RuleCall getMaxstepPragmaParserRuleCall_3() { return cMaxstepPragmaParserRuleCall_3; }

		//OutputPragma
		public RuleCall getOutputPragmaParserRuleCall_4() { return cOutputPragmaParserRuleCall_4; }

		//DoubleCalcPragma
		public RuleCall getDoubleCalcPragmaParserRuleCall_5() { return cDoubleCalcPragmaParserRuleCall_5; }

		//DumpResultPragma
		public RuleCall getDumpResultPragmaParserRuleCall_6() { return cDumpResultPragmaParserRuleCall_6; }
	}

	public class StopPragmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.StopPragma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cWhenKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cClockAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cClockClockCrossReference_2_0 = (CrossReference)cClockAssignment_2.eContents().get(0);
		private final RuleCall cClockClockIDTerminalRuleCall_2_0_1 = (RuleCall)cClockClockCrossReference_2_0.eContents().get(1);
		
		//StopPragma:
		//	"@stop" "when" clock=[Clock];
		@Override public ParserRule getRule() { return rule; }

		//"@stop" "when" clock=[Clock]
		public Group getGroup() { return cGroup; }

		//"@stop"
		public Keyword getStopKeyword_0() { return cStopKeyword_0; }

		//"when"
		public Keyword getWhenKeyword_1() { return cWhenKeyword_1; }

		//clock=[Clock]
		public Assignment getClockAssignment_2() { return cClockAssignment_2; }

		//[Clock]
		public CrossReference getClockClockCrossReference_2_0() { return cClockClockCrossReference_2_0; }

		//ID
		public RuleCall getClockClockIDTerminalRuleCall_2_0_1() { return cClockClockIDTerminalRuleCall_2_0_1; }
	}

	public class TagrefPragmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.TagrefPragma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTagrefKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cClockAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cClockClockCrossReference_1_0 = (CrossReference)cClockAssignment_1.eContents().get(0);
		private final RuleCall cClockClockIDTerminalRuleCall_1_0_1 = (RuleCall)cClockClockCrossReference_1_0.eContents().get(1);
		
		//TagrefPragma:
		//	"@tagref" clock=[Clock];
		@Override public ParserRule getRule() { return rule; }

		//"@tagref" clock=[Clock]
		public Group getGroup() { return cGroup; }

		//"@tagref"
		public Keyword getTagrefKeyword_0() { return cTagrefKeyword_0; }

		//clock=[Clock]
		public Assignment getClockAssignment_1() { return cClockAssignment_1; }

		//[Clock]
		public CrossReference getClockClockCrossReference_1_0() { return cClockClockCrossReference_1_0; }

		//ID
		public RuleCall getClockClockIDTerminalRuleCall_1_0_1() { return cClockClockIDTerminalRuleCall_1_0_1; }
	}

	public class TracePragmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.TracePragma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTraceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cKindsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cKindsIDTerminalRuleCall_1_0 = (RuleCall)cKindsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cKindsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cKindsIDTerminalRuleCall_2_1_0 = (RuleCall)cKindsAssignment_2_1.eContents().get(0);
		
		//TracePragma:
		//	"@trace" kinds+=ID ("," kinds+=ID)*;
		@Override public ParserRule getRule() { return rule; }

		//"@trace" kinds+=ID ("," kinds+=ID)*
		public Group getGroup() { return cGroup; }

		//"@trace"
		public Keyword getTraceKeyword_0() { return cTraceKeyword_0; }

		//kinds+=ID
		public Assignment getKindsAssignment_1() { return cKindsAssignment_1; }

		//ID
		public RuleCall getKindsIDTerminalRuleCall_1_0() { return cKindsIDTerminalRuleCall_1_0; }

		//("," kinds+=ID)*
		public Group getGroup_2() { return cGroup_2; }

		//","
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }

		//kinds+=ID
		public Assignment getKindsAssignment_2_1() { return cKindsAssignment_2_1; }

		//ID
		public RuleCall getKindsIDTerminalRuleCall_2_1_0() { return cKindsIDTerminalRuleCall_2_1_0; }
	}

	public class MaxstepPragmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.MaxstepPragma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMaxstepKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueExpressionParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//MaxstepPragma:
		//	"@maxstep" value=Expression;
		@Override public ParserRule getRule() { return rule; }

		//"@maxstep" value=Expression
		public Group getGroup() { return cGroup; }

		//"@maxstep"
		public Keyword getMaxstepKeyword_0() { return cMaxstepKeyword_0; }

		//value=Expression
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//Expression
		public RuleCall getValueExpressionParserRuleCall_1_0() { return cValueExpressionParserRuleCall_1_0; }
	}

	public class OutputPragmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.OutputPragma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cOutputPragmaAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cOutputKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final Alternatives cTypeAlternatives_2_0 = (Alternatives)cTypeAssignment_2.eContents().get(0);
		private final Keyword cTypeVcdKeyword_2_0_0 = (Keyword)cTypeAlternatives_2_0.eContents().get(0);
		private final Keyword cTypeTikzKeyword_2_0_1 = (Keyword)cTypeAlternatives_2_0.eContents().get(1);
		private final Keyword cTypeSvgKeyword_2_0_2 = (Keyword)cTypeAlternatives_2_0.eContents().get(2);
		private final UnorderedGroup cUnorderedGroup_3 = (UnorderedGroup)cGroup.eContents().get(3);
		private final Group cGroup_3_0 = (Group)cUnorderedGroup_3.eContents().get(0);
		private final Assignment cSelectionAssignment_3_0_0 = (Assignment)cGroup_3_0.eContents().get(0);
		private final Keyword cSelectionSelectKeyword_3_0_0_0 = (Keyword)cSelectionAssignment_3_0_0.eContents().get(0);
		private final Assignment cSelectedClocksAssignment_3_0_1 = (Assignment)cGroup_3_0.eContents().get(1);
		private final RuleCall cSelectedClocksClockItemParserRuleCall_3_0_1_0 = (RuleCall)cSelectedClocksAssignment_3_0_1.eContents().get(0);
		private final Group cGroup_3_0_2 = (Group)cGroup_3_0.eContents().get(2);
		private final Keyword cCommaKeyword_3_0_2_0 = (Keyword)cGroup_3_0_2.eContents().get(0);
		private final Assignment cSelectedClocksAssignment_3_0_2_1 = (Assignment)cGroup_3_0_2.eContents().get(1);
		private final RuleCall cSelectedClocksClockItemParserRuleCall_3_0_2_1_0 = (RuleCall)cSelectedClocksAssignment_3_0_2_1.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cUnorderedGroup_3.eContents().get(1);
		private final Assignment cWindowAssignment_3_1_0 = (Assignment)cGroup_3_1.eContents().get(0);
		private final Keyword cWindowFromKeyword_3_1_0_0 = (Keyword)cWindowAssignment_3_1_0.eContents().get(0);
		private final Assignment cFromAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cFromExpressionParserRuleCall_3_1_1_0 = (RuleCall)cFromAssignment_3_1_1.eContents().get(0);
		private final Keyword cToKeyword_3_1_2 = (Keyword)cGroup_3_1.eContents().get(2);
		private final Assignment cToAssignment_3_1_3 = (Assignment)cGroup_3_1.eContents().get(3);
		private final RuleCall cToExpressionParserRuleCall_3_1_3_0 = (RuleCall)cToAssignment_3_1_3.eContents().get(0);
		private final Group cGroup_3_2 = (Group)cUnorderedGroup_3.eContents().get(2);
		private final Keyword cLabelKeyword_3_2_0 = (Keyword)cGroup_3_2.eContents().get(0);
		private final Keyword cIfKeyword_3_2_1 = (Keyword)cGroup_3_2.eContents().get(1);
		private final Assignment cLabelifAssignment_3_2_2 = (Assignment)cGroup_3_2.eContents().get(2);
		private final CrossReference cLabelifClockCrossReference_3_2_2_0 = (CrossReference)cLabelifAssignment_3_2_2.eContents().get(0);
		private final RuleCall cLabelifClockIDTerminalRuleCall_3_2_2_0_1 = (RuleCall)cLabelifClockCrossReference_3_2_2_0.eContents().get(1);
		private final Group cGroup_3_2_3 = (Group)cGroup_3_2.eContents().get(3);
		private final Keyword cCommaKeyword_3_2_3_0 = (Keyword)cGroup_3_2_3.eContents().get(0);
		private final Assignment cLabelifAssignment_3_2_3_1 = (Assignment)cGroup_3_2_3.eContents().get(1);
		private final CrossReference cLabelifClockCrossReference_3_2_3_1_0 = (CrossReference)cLabelifAssignment_3_2_3_1.eContents().get(0);
		private final RuleCall cLabelifClockIDTerminalRuleCall_3_2_3_1_0_1 = (RuleCall)cLabelifClockCrossReference_3_2_3_1_0.eContents().get(1);
		private final Group cGroup_3_3 = (Group)cUnorderedGroup_3.eContents().get(3);
		private final Assignment cXscaledAssignment_3_3_0 = (Assignment)cGroup_3_3.eContents().get(0);
		private final Keyword cXscaledXscaleKeyword_3_3_0_0 = (Keyword)cXscaledAssignment_3_3_0.eContents().get(0);
		private final Assignment cXscaleAssignment_3_3_1 = (Assignment)cGroup_3_3.eContents().get(1);
		private final RuleCall cXscaleExpressionParserRuleCall_3_3_1_0 = (RuleCall)cXscaleAssignment_3_3_1.eContents().get(0);
		private final Group cGroup_3_4 = (Group)cUnorderedGroup_3.eContents().get(4);
		private final Keyword cBorderKeyword_3_4_0 = (Keyword)cGroup_3_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_4_1 = (Keyword)cGroup_3_4.eContents().get(1);
		private final Assignment cBorderAssignment_3_4_2 = (Assignment)cGroup_3_4.eContents().get(2);
		private final RuleCall cBorderSTRINGTerminalRuleCall_3_4_2_0 = (RuleCall)cBorderAssignment_3_4_2.eContents().get(0);
		private final Group cGroup_3_5 = (Group)cUnorderedGroup_3.eContents().get(5);
		private final Keyword cCssKeyword_3_5_0 = (Keyword)cGroup_3_5.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_5_1 = (Keyword)cGroup_3_5.eContents().get(1);
		private final Assignment cCssAssignment_3_5_2 = (Assignment)cGroup_3_5.eContents().get(2);
		private final RuleCall cCssSTRINGTerminalRuleCall_3_5_2_0 = (RuleCall)cCssAssignment_3_5_2.eContents().get(0);
		private final Assignment cNodefcssAssignment_3_6 = (Assignment)cUnorderedGroup_3.eContents().get(6);
		private final Keyword cNodefcssNoDefaultCssKeyword_3_6_0 = (Keyword)cNodefcssAssignment_3_6.eContents().get(0);
		private final Group cGroup_3_7 = (Group)cUnorderedGroup_3.eContents().get(7);
		private final Keyword cJavascriptKeyword_3_7_0 = (Keyword)cGroup_3_7.eContents().get(0);
		private final Keyword cEqualsSignKeyword_3_7_1 = (Keyword)cGroup_3_7.eContents().get(1);
		private final Assignment cJvsAssignment_3_7_2 = (Assignment)cGroup_3_7.eContents().get(2);
		private final RuleCall cJvsSTRINGTerminalRuleCall_3_7_2_0 = (RuleCall)cJvsAssignment_3_7_2.eContents().get(0);
		private final Group cGroup_3_8 = (Group)cUnorderedGroup_3.eContents().get(8);
		private final Assignment cStandaloneAssignment_3_8_0 = (Assignment)cGroup_3_8.eContents().get(0);
		private final Keyword cStandaloneStandaloneKeyword_3_8_0_0 = (Keyword)cStandaloneAssignment_3_8_0.eContents().get(0);
		private final Assignment cOverwriteAssignment_3_8_1 = (Assignment)cGroup_3_8.eContents().get(1);
		private final Keyword cOverwriteOverwriteKeyword_3_8_1_0 = (Keyword)cOverwriteAssignment_3_8_1.eContents().get(0);
		
		//OutputPragma:
		//	{OutputPragma} "@output" type=("vcd" | "tikz" | "svg") ((selection?="select" selectedClocks+=ClockItem (","
		//	selectedClocks+=ClockItem)*)?
		//	& (window?="from" from=Expression "to" to=Expression)?
		//	& ("label" "if" labelif+=[Clock] ("," labelif+=[Clock])*)?
		//	& (xscaled?="xscale" xscale=Expression)?
		//	& ("border" "=" border=STRING)?
		//	& ("css" "=" css=STRING)?
		//	& nodefcss?="no-default-css"?
		//	& ("javascript" "=" jvs=STRING)?
		//	& (standalone?="standalone" overwrite?="overwrite"?)?);
		@Override public ParserRule getRule() { return rule; }

		//{OutputPragma} "@output" type=("vcd" | "tikz" | "svg") ((selection?="select" selectedClocks+=ClockItem (","
		//selectedClocks+=ClockItem)*)? & (window?="from" from=Expression "to" to=Expression)? & ("label" "if" labelif+=[Clock]
		//("," labelif+=[Clock])*)? & (xscaled?="xscale" xscale=Expression)? & ("border" "=" border=STRING)? & ("css" "="
		//css=STRING)? & nodefcss?="no-default-css"? & ("javascript" "=" jvs=STRING)? & (standalone?="standalone"
		//overwrite?="overwrite"?)?)
		public Group getGroup() { return cGroup; }

		//{OutputPragma}
		public Action getOutputPragmaAction_0() { return cOutputPragmaAction_0; }

		//"@output"
		public Keyword getOutputKeyword_1() { return cOutputKeyword_1; }

		//type=("vcd" | "tikz" | "svg")
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }

		//("vcd" | "tikz" | "svg")
		public Alternatives getTypeAlternatives_2_0() { return cTypeAlternatives_2_0; }

		//"vcd"
		public Keyword getTypeVcdKeyword_2_0_0() { return cTypeVcdKeyword_2_0_0; }

		//"tikz"
		public Keyword getTypeTikzKeyword_2_0_1() { return cTypeTikzKeyword_2_0_1; }

		//"svg"
		public Keyword getTypeSvgKeyword_2_0_2() { return cTypeSvgKeyword_2_0_2; }

		//((selection?="select" selectedClocks+=ClockItem ("," selectedClocks+=ClockItem)*)? & (window?="from" from=Expression
		//"to" to=Expression)? & ("label" "if" labelif+=[Clock] ("," labelif+=[Clock])*)? & (xscaled?="xscale"
		//xscale=Expression)? & ("border" "=" border=STRING)? & ("css" "=" css=STRING)? & nodefcss?="no-default-css"? &
		//("javascript" "=" jvs=STRING)? & (standalone?="standalone" overwrite?="overwrite"?)?)
		public UnorderedGroup getUnorderedGroup_3() { return cUnorderedGroup_3; }

		//(selection?="select" selectedClocks+=ClockItem ("," selectedClocks+=ClockItem)*)?
		public Group getGroup_3_0() { return cGroup_3_0; }

		//selection?="select"
		public Assignment getSelectionAssignment_3_0_0() { return cSelectionAssignment_3_0_0; }

		//"select"
		public Keyword getSelectionSelectKeyword_3_0_0_0() { return cSelectionSelectKeyword_3_0_0_0; }

		//selectedClocks+=ClockItem
		public Assignment getSelectedClocksAssignment_3_0_1() { return cSelectedClocksAssignment_3_0_1; }

		//ClockItem
		public RuleCall getSelectedClocksClockItemParserRuleCall_3_0_1_0() { return cSelectedClocksClockItemParserRuleCall_3_0_1_0; }

		//("," selectedClocks+=ClockItem)*
		public Group getGroup_3_0_2() { return cGroup_3_0_2; }

		//","
		public Keyword getCommaKeyword_3_0_2_0() { return cCommaKeyword_3_0_2_0; }

		//selectedClocks+=ClockItem
		public Assignment getSelectedClocksAssignment_3_0_2_1() { return cSelectedClocksAssignment_3_0_2_1; }

		//ClockItem
		public RuleCall getSelectedClocksClockItemParserRuleCall_3_0_2_1_0() { return cSelectedClocksClockItemParserRuleCall_3_0_2_1_0; }

		//(window?="from" from=Expression "to" to=Expression)?
		public Group getGroup_3_1() { return cGroup_3_1; }

		//window?="from"
		public Assignment getWindowAssignment_3_1_0() { return cWindowAssignment_3_1_0; }

		//"from"
		public Keyword getWindowFromKeyword_3_1_0_0() { return cWindowFromKeyword_3_1_0_0; }

		//from=Expression
		public Assignment getFromAssignment_3_1_1() { return cFromAssignment_3_1_1; }

		//Expression
		public RuleCall getFromExpressionParserRuleCall_3_1_1_0() { return cFromExpressionParserRuleCall_3_1_1_0; }

		//"to"
		public Keyword getToKeyword_3_1_2() { return cToKeyword_3_1_2; }

		//to=Expression
		public Assignment getToAssignment_3_1_3() { return cToAssignment_3_1_3; }

		//Expression
		public RuleCall getToExpressionParserRuleCall_3_1_3_0() { return cToExpressionParserRuleCall_3_1_3_0; }

		//("label" "if" labelif+=[Clock] ("," labelif+=[Clock])*)?
		public Group getGroup_3_2() { return cGroup_3_2; }

		//"label"
		public Keyword getLabelKeyword_3_2_0() { return cLabelKeyword_3_2_0; }

		//"if"
		public Keyword getIfKeyword_3_2_1() { return cIfKeyword_3_2_1; }

		//labelif+=[Clock]
		public Assignment getLabelifAssignment_3_2_2() { return cLabelifAssignment_3_2_2; }

		//[Clock]
		public CrossReference getLabelifClockCrossReference_3_2_2_0() { return cLabelifClockCrossReference_3_2_2_0; }

		//ID
		public RuleCall getLabelifClockIDTerminalRuleCall_3_2_2_0_1() { return cLabelifClockIDTerminalRuleCall_3_2_2_0_1; }

		//("," labelif+=[Clock])*
		public Group getGroup_3_2_3() { return cGroup_3_2_3; }

		//","
		public Keyword getCommaKeyword_3_2_3_0() { return cCommaKeyword_3_2_3_0; }

		//labelif+=[Clock]
		public Assignment getLabelifAssignment_3_2_3_1() { return cLabelifAssignment_3_2_3_1; }

		//[Clock]
		public CrossReference getLabelifClockCrossReference_3_2_3_1_0() { return cLabelifClockCrossReference_3_2_3_1_0; }

		//ID
		public RuleCall getLabelifClockIDTerminalRuleCall_3_2_3_1_0_1() { return cLabelifClockIDTerminalRuleCall_3_2_3_1_0_1; }

		//(xscaled?="xscale" xscale=Expression)?
		public Group getGroup_3_3() { return cGroup_3_3; }

		//xscaled?="xscale"
		public Assignment getXscaledAssignment_3_3_0() { return cXscaledAssignment_3_3_0; }

		//"xscale"
		public Keyword getXscaledXscaleKeyword_3_3_0_0() { return cXscaledXscaleKeyword_3_3_0_0; }

		//xscale=Expression
		public Assignment getXscaleAssignment_3_3_1() { return cXscaleAssignment_3_3_1; }

		//Expression
		public RuleCall getXscaleExpressionParserRuleCall_3_3_1_0() { return cXscaleExpressionParserRuleCall_3_3_1_0; }

		//("border" "=" border=STRING)?
		public Group getGroup_3_4() { return cGroup_3_4; }

		//"border"
		public Keyword getBorderKeyword_3_4_0() { return cBorderKeyword_3_4_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_4_1() { return cEqualsSignKeyword_3_4_1; }

		//border=STRING
		public Assignment getBorderAssignment_3_4_2() { return cBorderAssignment_3_4_2; }

		//STRING
		public RuleCall getBorderSTRINGTerminalRuleCall_3_4_2_0() { return cBorderSTRINGTerminalRuleCall_3_4_2_0; }

		//("css" "=" css=STRING)?
		public Group getGroup_3_5() { return cGroup_3_5; }

		//"css"
		public Keyword getCssKeyword_3_5_0() { return cCssKeyword_3_5_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_5_1() { return cEqualsSignKeyword_3_5_1; }

		//css=STRING
		public Assignment getCssAssignment_3_5_2() { return cCssAssignment_3_5_2; }

		//STRING
		public RuleCall getCssSTRINGTerminalRuleCall_3_5_2_0() { return cCssSTRINGTerminalRuleCall_3_5_2_0; }

		//nodefcss?="no-default-css"?
		public Assignment getNodefcssAssignment_3_6() { return cNodefcssAssignment_3_6; }

		//"no-default-css"
		public Keyword getNodefcssNoDefaultCssKeyword_3_6_0() { return cNodefcssNoDefaultCssKeyword_3_6_0; }

		//("javascript" "=" jvs=STRING)?
		public Group getGroup_3_7() { return cGroup_3_7; }

		//"javascript"
		public Keyword getJavascriptKeyword_3_7_0() { return cJavascriptKeyword_3_7_0; }

		//"="
		public Keyword getEqualsSignKeyword_3_7_1() { return cEqualsSignKeyword_3_7_1; }

		//jvs=STRING
		public Assignment getJvsAssignment_3_7_2() { return cJvsAssignment_3_7_2; }

		//STRING
		public RuleCall getJvsSTRINGTerminalRuleCall_3_7_2_0() { return cJvsSTRINGTerminalRuleCall_3_7_2_0; }

		//(standalone?="standalone" overwrite?="overwrite"?)?
		public Group getGroup_3_8() { return cGroup_3_8; }

		//standalone?="standalone"
		public Assignment getStandaloneAssignment_3_8_0() { return cStandaloneAssignment_3_8_0; }

		//"standalone"
		public Keyword getStandaloneStandaloneKeyword_3_8_0_0() { return cStandaloneStandaloneKeyword_3_8_0_0; }

		//overwrite?="overwrite"?
		public Assignment getOverwriteAssignment_3_8_1() { return cOverwriteAssignment_3_8_1; }

		//"overwrite"
		public Keyword getOverwriteOverwriteKeyword_3_8_1_0() { return cOverwriteOverwriteKeyword_3_8_1_0; }
	}

	public class ClockItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.ClockItem");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cClockAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cClockClockCrossReference_0_0 = (CrossReference)cClockAssignment_0.eContents().get(0);
		private final RuleCall cClockClockIDTerminalRuleCall_0_0_1 = (RuleCall)cClockClockCrossReference_0_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cNewNameAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cNewNameIDTerminalRuleCall_1_1_0 = (RuleCall)cNewNameAssignment_1_1.eContents().get(0);
		
		//// supports clock renaming (for long clock names)
		//ClockItem:
		//	clock=[Clock] ("->" newName=ID)?;
		@Override public ParserRule getRule() { return rule; }

		//clock=[Clock] ("->" newName=ID)?
		public Group getGroup() { return cGroup; }

		//clock=[Clock]
		public Assignment getClockAssignment_0() { return cClockAssignment_0; }

		//[Clock]
		public CrossReference getClockClockCrossReference_0_0() { return cClockClockCrossReference_0_0; }

		//ID
		public RuleCall getClockClockIDTerminalRuleCall_0_0_1() { return cClockClockIDTerminalRuleCall_0_0_1; }

		//("->" newName=ID)?
		public Group getGroup_1() { return cGroup_1; }

		//"->"
		public Keyword getHyphenMinusGreaterThanSignKeyword_1_0() { return cHyphenMinusGreaterThanSignKeyword_1_0; }

		//newName=ID
		public Assignment getNewNameAssignment_1_1() { return cNewNameAssignment_1_1; }

		//ID
		public RuleCall getNewNameIDTerminalRuleCall_1_1_0() { return cNewNameIDTerminalRuleCall_1_1_0; }
	}

	public class DoubleCalcPragmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.DoubleCalcPragma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoublecalcKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cDigitsKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNum_digitsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNum_digitsBIG_INTTerminalRuleCall_3_0 = (RuleCall)cNum_digitsAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cRoundAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final Keyword cRoundLeftParenthesisKeyword_4_0_0 = (Keyword)cRoundAssignment_4_0.eContents().get(0);
		private final Assignment cRounding_modeAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cRounding_modeROUNDING_MODEEnumRuleCall_4_1_0 = (RuleCall)cRounding_modeAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//DoubleCalcPragma:
		//	"@doublecalc" "digits" "=" num_digits=BIG_INT (round?="(" rounding_mode=ROUNDING_MODE ")")?;
		@Override public ParserRule getRule() { return rule; }

		//"@doublecalc" "digits" "=" num_digits=BIG_INT (round?="(" rounding_mode=ROUNDING_MODE ")")?
		public Group getGroup() { return cGroup; }

		//"@doublecalc"
		public Keyword getDoublecalcKeyword_0() { return cDoublecalcKeyword_0; }

		//"digits"
		public Keyword getDigitsKeyword_1() { return cDigitsKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//num_digits=BIG_INT
		public Assignment getNum_digitsAssignment_3() { return cNum_digitsAssignment_3; }

		//BIG_INT
		public RuleCall getNum_digitsBIG_INTTerminalRuleCall_3_0() { return cNum_digitsBIG_INTTerminalRuleCall_3_0; }

		//(round?="(" rounding_mode=ROUNDING_MODE ")")?
		public Group getGroup_4() { return cGroup_4; }

		//round?="("
		public Assignment getRoundAssignment_4_0() { return cRoundAssignment_4_0; }

		//"("
		public Keyword getRoundLeftParenthesisKeyword_4_0_0() { return cRoundLeftParenthesisKeyword_4_0_0; }

		//rounding_mode=ROUNDING_MODE
		public Assignment getRounding_modeAssignment_4_1() { return cRounding_modeAssignment_4_1; }

		//ROUNDING_MODE
		public RuleCall getRounding_modeROUNDING_MODEEnumRuleCall_4_1_0() { return cRounding_modeROUNDING_MODEEnumRuleCall_4_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_4_2() { return cRightParenthesisKeyword_4_2; }
	}

	public class DumpResultPragmaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.DumpResultPragma");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDumpResultPragmaAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDumpresKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//DumpResultPragma:
		//	{DumpResultPragma} "@dumpres";
		@Override public ParserRule getRule() { return rule; }

		//{DumpResultPragma} "@dumpres"
		public Group getGroup() { return cGroup; }

		//{DumpResultPragma}
		public Action getDumpResultPragmaAction_0() { return cDumpResultPragmaAction_0; }

		//"@dumpres"
		public Keyword getDumpresKeyword_1() { return cDumpresKeyword_1; }
	}
	
	
	public class TypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTUNITEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTUNITUClockKeyword_0_0 = (Keyword)cTUNITEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cTUNITEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cTUNITUnitClockKeyword_1_0 = (Keyword)cTUNITEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cTINTEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cTINTZClockKeyword_2_0 = (Keyword)cTINTEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cTINTEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cTINTIntClockKeyword_3_0 = (Keyword)cTINTEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cTDECEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cTDECDClockKeyword_4_0 = (Keyword)cTDECEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cTDECEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cTDECDecimalClockKeyword_5_0 = (Keyword)cTDECEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cTRATEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cTRATQClockKeyword_6_0 = (Keyword)cTRATEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cTRATEnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cTRATRationalClockKeyword_7_0 = (Keyword)cTRATEnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cTFLOATEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cTFLOATFClockKeyword_8_0 = (Keyword)cTFLOATEnumLiteralDeclaration_8.eContents().get(0);
		private final EnumLiteralDeclaration cTFLOATEnumLiteralDeclaration_9 = (EnumLiteralDeclaration)cAlternatives.eContents().get(9);
		private final Keyword cTFLOATFloatClockKeyword_9_0 = (Keyword)cTFLOATEnumLiteralDeclaration_9.eContents().get(0);
		private final EnumLiteralDeclaration cTFLOATEnumLiteralDeclaration_10 = (EnumLiteralDeclaration)cAlternatives.eContents().get(10);
		private final Keyword cTFLOATDoubleClockKeyword_10_0 = (Keyword)cTFLOATEnumLiteralDeclaration_10.eContents().get(0);
		
		//enum Type:
		//	TUNIT="U-clock" | TUNIT="unit-clock"
		//	| TINT="Z-clock" | TINT="int-clock"
		//	| TDEC="D-clock" | TDEC="decimal-clock"
		//	| TRAT="Q-clock" | TRAT="rational-clock"
		//	| TFLOAT="F-clock" | TFLOAT="float-clock" | TFLOAT="double-clock";
		public EnumRule getRule() { return rule; }

		//TUNIT="U-clock" | TUNIT="unit-clock" | TINT="Z-clock" | TINT="int-clock" | TDEC="D-clock" | TDEC="decimal-clock" |
		//TRAT="Q-clock" | TRAT="rational-clock" | TFLOAT="F-clock" | TFLOAT="float-clock" | TFLOAT="double-clock"
		public Alternatives getAlternatives() { return cAlternatives; }

		//TUNIT="U-clock"
		public EnumLiteralDeclaration getTUNITEnumLiteralDeclaration_0() { return cTUNITEnumLiteralDeclaration_0; }

		//"U-clock"
		public Keyword getTUNITUClockKeyword_0_0() { return cTUNITUClockKeyword_0_0; }

		//TUNIT="unit-clock"
		public EnumLiteralDeclaration getTUNITEnumLiteralDeclaration_1() { return cTUNITEnumLiteralDeclaration_1; }

		//"unit-clock"
		public Keyword getTUNITUnitClockKeyword_1_0() { return cTUNITUnitClockKeyword_1_0; }

		//TINT="Z-clock"
		public EnumLiteralDeclaration getTINTEnumLiteralDeclaration_2() { return cTINTEnumLiteralDeclaration_2; }

		//"Z-clock"
		public Keyword getTINTZClockKeyword_2_0() { return cTINTZClockKeyword_2_0; }

		//TINT="int-clock"
		public EnumLiteralDeclaration getTINTEnumLiteralDeclaration_3() { return cTINTEnumLiteralDeclaration_3; }

		//"int-clock"
		public Keyword getTINTIntClockKeyword_3_0() { return cTINTIntClockKeyword_3_0; }

		//TDEC="D-clock"
		public EnumLiteralDeclaration getTDECEnumLiteralDeclaration_4() { return cTDECEnumLiteralDeclaration_4; }

		//"D-clock"
		public Keyword getTDECDClockKeyword_4_0() { return cTDECDClockKeyword_4_0; }

		//TDEC="decimal-clock"
		public EnumLiteralDeclaration getTDECEnumLiteralDeclaration_5() { return cTDECEnumLiteralDeclaration_5; }

		//"decimal-clock"
		public Keyword getTDECDecimalClockKeyword_5_0() { return cTDECDecimalClockKeyword_5_0; }

		//TRAT="Q-clock"
		public EnumLiteralDeclaration getTRATEnumLiteralDeclaration_6() { return cTRATEnumLiteralDeclaration_6; }

		//"Q-clock"
		public Keyword getTRATQClockKeyword_6_0() { return cTRATQClockKeyword_6_0; }

		//TRAT="rational-clock"
		public EnumLiteralDeclaration getTRATEnumLiteralDeclaration_7() { return cTRATEnumLiteralDeclaration_7; }

		//"rational-clock"
		public Keyword getTRATRationalClockKeyword_7_0() { return cTRATRationalClockKeyword_7_0; }

		//TFLOAT="F-clock"
		public EnumLiteralDeclaration getTFLOATEnumLiteralDeclaration_8() { return cTFLOATEnumLiteralDeclaration_8; }

		//"F-clock"
		public Keyword getTFLOATFClockKeyword_8_0() { return cTFLOATFClockKeyword_8_0; }

		//TFLOAT="float-clock"
		public EnumLiteralDeclaration getTFLOATEnumLiteralDeclaration_9() { return cTFLOATEnumLiteralDeclaration_9; }

		//"float-clock"
		public Keyword getTFLOATFloatClockKeyword_9_0() { return cTFLOATFloatClockKeyword_9_0; }

		//TFLOAT="double-clock"
		public EnumLiteralDeclaration getTFLOATEnumLiteralDeclaration_10() { return cTFLOATEnumLiteralDeclaration_10; }

		//"double-clock"
		public Keyword getTFLOATDoubleClockKeyword_10_0() { return cTFLOATDoubleClockKeyword_10_0; }
	}

	public class ValueTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.ValueType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTINTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTINTIntKeyword_0_0 = (Keyword)cTINTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cTDECEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cTDECDecimalKeyword_1_0 = (Keyword)cTDECEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cTRATEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cTRATRationalKeyword_2_0 = (Keyword)cTRATEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cTFLOATEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cTFLOATDoubleKeyword_3_0 = (Keyword)cTFLOATEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cTFLOATEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cTFLOATFloatKeyword_4_0 = (Keyword)cTFLOATEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum ValueType:
		//	TINT="int"
		//	| TDEC="decimal"
		//	| TRAT="rational"
		//	| TFLOAT="double" | TFLOAT="float";
		public EnumRule getRule() { return rule; }

		//TINT="int" | TDEC="decimal" | TRAT="rational" | TFLOAT="double" | TFLOAT="float"
		public Alternatives getAlternatives() { return cAlternatives; }

		//TINT="int"
		public EnumLiteralDeclaration getTINTEnumLiteralDeclaration_0() { return cTINTEnumLiteralDeclaration_0; }

		//"int"
		public Keyword getTINTIntKeyword_0_0() { return cTINTIntKeyword_0_0; }

		//TDEC="decimal"
		public EnumLiteralDeclaration getTDECEnumLiteralDeclaration_1() { return cTDECEnumLiteralDeclaration_1; }

		//"decimal"
		public Keyword getTDECDecimalKeyword_1_0() { return cTDECDecimalKeyword_1_0; }

		//TRAT="rational"
		public EnumLiteralDeclaration getTRATEnumLiteralDeclaration_2() { return cTRATEnumLiteralDeclaration_2; }

		//"rational"
		public Keyword getTRATRationalKeyword_2_0() { return cTRATRationalKeyword_2_0; }

		//TFLOAT="double"
		public EnumLiteralDeclaration getTFLOATEnumLiteralDeclaration_3() { return cTFLOATEnumLiteralDeclaration_3; }

		//"double"
		public Keyword getTFLOATDoubleKeyword_3_0() { return cTFLOATDoubleKeyword_3_0; }

		//TFLOAT="float"
		public EnumLiteralDeclaration getTFLOATEnumLiteralDeclaration_4() { return cTFLOATEnumLiteralDeclaration_4; }

		//"float"
		public Keyword getTFLOATFloatKeyword_4_0() { return cTFLOATFloatKeyword_4_0; }
	}

	public class OpTermElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.OpTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cPLUSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cPLUSPlusSignKeyword_0_0 = (Keyword)cPLUSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMINUSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMINUSHyphenMinusKeyword_1_0 = (Keyword)cMINUSEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum OpTerm returns Op:
		//	PLUS="+" | MINUS="-";
		public EnumRule getRule() { return rule; }

		//PLUS="+" | MINUS="-"
		public Alternatives getAlternatives() { return cAlternatives; }

		//PLUS="+"
		public EnumLiteralDeclaration getPLUSEnumLiteralDeclaration_0() { return cPLUSEnumLiteralDeclaration_0; }

		//"+"
		public Keyword getPLUSPlusSignKeyword_0_0() { return cPLUSPlusSignKeyword_0_0; }

		//MINUS="-"
		public EnumLiteralDeclaration getMINUSEnumLiteralDeclaration_1() { return cMINUSEnumLiteralDeclaration_1; }

		//"-"
		public Keyword getMINUSHyphenMinusKeyword_1_0() { return cMINUSHyphenMinusKeyword_1_0; }
	}

	public class OpFactElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.OpFact");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cTIMESEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cTIMESAsteriskKeyword_0_0 = (Keyword)cTIMESEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVSolidusKeyword_1_0 = (Keyword)cDIVEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum OpFact returns Op:
		//	TIMES="*" | DIV="/";
		public EnumRule getRule() { return rule; }

		//TIMES="*" | DIV="/"
		public Alternatives getAlternatives() { return cAlternatives; }

		//TIMES="*"
		public EnumLiteralDeclaration getTIMESEnumLiteralDeclaration_0() { return cTIMESEnumLiteralDeclaration_0; }

		//"*"
		public Keyword getTIMESAsteriskKeyword_0_0() { return cTIMESAsteriskKeyword_0_0; }

		//DIV="/"
		public EnumLiteralDeclaration getDIVEnumLiteralDeclaration_1() { return cDIVEnumLiteralDeclaration_1; }

		//"/"
		public Keyword getDIVSolidusKeyword_1_0() { return cDIVSolidusKeyword_1_0; }
	}

	public class ROUNDING_MODEElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.ROUNDING_MODE");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cROUND_UPEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cROUND_UPRound_upKeyword_0_0 = (Keyword)cROUND_UPEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cROUND_DOWNEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cROUND_DOWNRound_downKeyword_1_0 = (Keyword)cROUND_DOWNEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cROUND_CEILINGEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cROUND_CEILINGRound_ceilKeyword_2_0 = (Keyword)cROUND_CEILINGEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cROUND_FLOOREnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cROUND_FLOORRound_floorKeyword_3_0 = (Keyword)cROUND_FLOOREnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cROUND_HALF_UPEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cROUND_HALF_UPRound_half_upKeyword_4_0 = (Keyword)cROUND_HALF_UPEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cROUND_HALF_DOWNEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cROUND_HALF_DOWNRound_half_downKeyword_5_0 = (Keyword)cROUND_HALF_DOWNEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cROUND_HALF_EVENEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cROUND_HALF_EVENRound_half_evenKeyword_6_0 = (Keyword)cROUND_HALF_EVENEnumLiteralDeclaration_6.eContents().get(0);
		
		//enum ROUNDING_MODE:
		//	ROUND_UP="round_up"
		//	| ROUND_DOWN="round_down"
		//	| ROUND_CEILING="round_ceil"
		//	| ROUND_FLOOR="round_floor"
		//	| ROUND_HALF_UP="round_half_up"
		//	| ROUND_HALF_DOWN="round_half_down"
		//	| ROUND_HALF_EVEN="round_half_even";
		public EnumRule getRule() { return rule; }

		//ROUND_UP="round_up" | ROUND_DOWN="round_down" | ROUND_CEILING="round_ceil" | ROUND_FLOOR="round_floor" |
		//ROUND_HALF_UP="round_half_up" | ROUND_HALF_DOWN="round_half_down" | ROUND_HALF_EVEN="round_half_even"
		public Alternatives getAlternatives() { return cAlternatives; }

		//ROUND_UP="round_up"
		public EnumLiteralDeclaration getROUND_UPEnumLiteralDeclaration_0() { return cROUND_UPEnumLiteralDeclaration_0; }

		//"round_up"
		public Keyword getROUND_UPRound_upKeyword_0_0() { return cROUND_UPRound_upKeyword_0_0; }

		//ROUND_DOWN="round_down"
		public EnumLiteralDeclaration getROUND_DOWNEnumLiteralDeclaration_1() { return cROUND_DOWNEnumLiteralDeclaration_1; }

		//"round_down"
		public Keyword getROUND_DOWNRound_downKeyword_1_0() { return cROUND_DOWNRound_downKeyword_1_0; }

		//ROUND_CEILING="round_ceil"
		public EnumLiteralDeclaration getROUND_CEILINGEnumLiteralDeclaration_2() { return cROUND_CEILINGEnumLiteralDeclaration_2; }

		//"round_ceil"
		public Keyword getROUND_CEILINGRound_ceilKeyword_2_0() { return cROUND_CEILINGRound_ceilKeyword_2_0; }

		//ROUND_FLOOR="round_floor"
		public EnumLiteralDeclaration getROUND_FLOOREnumLiteralDeclaration_3() { return cROUND_FLOOREnumLiteralDeclaration_3; }

		//"round_floor"
		public Keyword getROUND_FLOORRound_floorKeyword_3_0() { return cROUND_FLOORRound_floorKeyword_3_0; }

		//ROUND_HALF_UP="round_half_up"
		public EnumLiteralDeclaration getROUND_HALF_UPEnumLiteralDeclaration_4() { return cROUND_HALF_UPEnumLiteralDeclaration_4; }

		//"round_half_up"
		public Keyword getROUND_HALF_UPRound_half_upKeyword_4_0() { return cROUND_HALF_UPRound_half_upKeyword_4_0; }

		//ROUND_HALF_DOWN="round_half_down"
		public EnumLiteralDeclaration getROUND_HALF_DOWNEnumLiteralDeclaration_5() { return cROUND_HALF_DOWNEnumLiteralDeclaration_5; }

		//"round_half_down"
		public Keyword getROUND_HALF_DOWNRound_half_downKeyword_5_0() { return cROUND_HALF_DOWNRound_half_downKeyword_5_0; }

		//ROUND_HALF_EVEN="round_half_even"
		public EnumLiteralDeclaration getROUND_HALF_EVENEnumLiteralDeclaration_6() { return cROUND_HALF_EVENEnumLiteralDeclaration_6; }

		//"round_half_even"
		public Keyword getROUND_HALF_EVENRound_half_evenKeyword_6_0() { return cROUND_HALF_EVENRound_half_evenKeyword_6_0; }
	}
	
	private final SpecificationElements pSpecification;
	private final ClockElements pClock;
	private final ClockQualifierElements pClockQualifier;
	private final PeriodicQualifierElements pPeriodicQualifier;
	private final SporadicQualifierElements pSporadicQualifier;
	private final TypeElements eType;
	private final ValueTypeElements eValueType;
	private final RelationElements pRelation;
	private final ImplicationRelationElements pImplicationRelation;
	private final AwaitImplicationElements pAwaitImplication;
	private final ImplicationQualifierElements pImplicationQualifier;
	private final FilteredQualifierElements pFilteredQualifier;
	private final EveryQualifierElements pEveryQualifier;
	private final DelayedQualifierElements pDelayedQualifier;
	private final SustainedQualifierElements pSustainedQualifier;
	private final TimeDelayedQualifierElements pTimeDelayedQualifier;
	private final LetElements pLet;
	private final ValueElements pValue;
	private final IntegerValueElements pIntegerValue;
	private final DecimalValueElements pDecimalValue;
	private final FloatValueElements pFloatValue;
	private final RationalValueElements pRationalValue;
	private final LetValueElements pLetValue;
	private final OpTermElements eOpTerm;
	private final OpFactElements eOpFact;
	private final ExpressionElements pExpression;
	private final TermElements pTerm;
	private final FactorElements pFactor;
	private final BasicExprElements pBasicExpr;
	private final CastElements pCast;
	private final IntCastElements pIntCast;
	private final FloatCastElements pFloatCast;
	private final DecimalCastElements pDecimalCast;
	private final RationalCastElements pRationalCast;
	private final WhenQualifierElements pWhenQualifier;
	private final NextQualifierElements pNextQualifier;
	private final PatternElements pPattern;
	private final TagRelationElements pTagRelation;
	private final TagExprElements pTagExpr;
	private final PragmaElements pPragma;
	private final StopPragmaElements pStopPragma;
	private final TagrefPragmaElements pTagrefPragma;
	private final TracePragmaElements pTracePragma;
	private final MaxstepPragmaElements pMaxstepPragma;
	private final OutputPragmaElements pOutputPragma;
	private final ClockItemElements pClockItem;
	private final DoubleCalcPragmaElements pDoubleCalcPragma;
	private final DumpResultPragmaElements pDumpResultPragma;
	private final ROUNDING_MODEElements eROUNDING_MODE;
	private final TerminalRule tDIGIT;
	private final TerminalRule tSIGN;
	private final TerminalRule tEXPONENT;
	private final TerminalRule tBIG_INT;
	private final TerminalRule tFLOAT;
	private final TerminalRule tBIG_DECIMAL;
	private final TerminalRule tRATIONAL;
	private final TerminalRule tID;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tSTRING;
	private final TerminalRule tWS;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public TESLGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pSpecification = new SpecificationElements();
		this.pClock = new ClockElements();
		this.pClockQualifier = new ClockQualifierElements();
		this.pPeriodicQualifier = new PeriodicQualifierElements();
		this.pSporadicQualifier = new SporadicQualifierElements();
		this.eType = new TypeElements();
		this.eValueType = new ValueTypeElements();
		this.pRelation = new RelationElements();
		this.pImplicationRelation = new ImplicationRelationElements();
		this.pAwaitImplication = new AwaitImplicationElements();
		this.pImplicationQualifier = new ImplicationQualifierElements();
		this.pFilteredQualifier = new FilteredQualifierElements();
		this.pEveryQualifier = new EveryQualifierElements();
		this.pDelayedQualifier = new DelayedQualifierElements();
		this.pSustainedQualifier = new SustainedQualifierElements();
		this.pTimeDelayedQualifier = new TimeDelayedQualifierElements();
		this.pLet = new LetElements();
		this.pValue = new ValueElements();
		this.pIntegerValue = new IntegerValueElements();
		this.pDecimalValue = new DecimalValueElements();
		this.pFloatValue = new FloatValueElements();
		this.pRationalValue = new RationalValueElements();
		this.pLetValue = new LetValueElements();
		this.eOpTerm = new OpTermElements();
		this.eOpFact = new OpFactElements();
		this.pExpression = new ExpressionElements();
		this.pTerm = new TermElements();
		this.pFactor = new FactorElements();
		this.pBasicExpr = new BasicExprElements();
		this.pCast = new CastElements();
		this.pIntCast = new IntCastElements();
		this.pFloatCast = new FloatCastElements();
		this.pDecimalCast = new DecimalCastElements();
		this.pRationalCast = new RationalCastElements();
		this.pWhenQualifier = new WhenQualifierElements();
		this.pNextQualifier = new NextQualifierElements();
		this.pPattern = new PatternElements();
		this.pTagRelation = new TagRelationElements();
		this.pTagExpr = new TagExprElements();
		this.pPragma = new PragmaElements();
		this.pStopPragma = new StopPragmaElements();
		this.pTagrefPragma = new TagrefPragmaElements();
		this.pTracePragma = new TracePragmaElements();
		this.pMaxstepPragma = new MaxstepPragmaElements();
		this.pOutputPragma = new OutputPragmaElements();
		this.pClockItem = new ClockItemElements();
		this.pDoubleCalcPragma = new DoubleCalcPragmaElements();
		this.pDumpResultPragma = new DumpResultPragmaElements();
		this.eROUNDING_MODE = new ROUNDING_MODEElements();
		this.tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.DIGIT");
		this.tSIGN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.SIGN");
		this.tEXPONENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.EXPONENT");
		this.tBIG_INT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.BIG_INT");
		this.tFLOAT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.FLOAT");
		this.tBIG_DECIMAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.BIG_DECIMAL");
		this.tRATIONAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.RATIONAL");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.ID");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.SL_COMMENT");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.STRING");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.WS");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "fr.supelec.tesl.lang.TESL.ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("fr.supelec.tesl.lang.TESL".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//Specification:
	//	(decl+=Clock | rel+=Relation | let+=Let | pragmas+=Pragma)*;
	public SpecificationElements getSpecificationAccess() {
		return pSpecification;
	}
	
	public ParserRule getSpecificationRule() {
		return getSpecificationAccess().getRule();
	}

	//Clock:
	//	nongreedy?="nongreedy"? type=Type name=ID qual=ClockQualifier?;
	public ClockElements getClockAccess() {
		return pClock;
	}
	
	public ParserRule getClockRule() {
		return getClockAccess().getRule();
	}

	//ClockQualifier:
	//	PeriodicQualifier | SporadicQualifier;
	public ClockQualifierElements getClockQualifierAccess() {
		return pClockQualifier;
	}
	
	public ParserRule getClockQualifierRule() {
		return getClockQualifierAccess().getRule();
	}

	//PeriodicQualifier:
	//	"periodic" period=Expression ("offset" offset=Expression)?;
	public PeriodicQualifierElements getPeriodicQualifierAccess() {
		return pPeriodicQualifier;
	}
	
	public ParserRule getPeriodicQualifierRule() {
		return getPeriodicQualifierAccess().getRule();
	}

	//SporadicQualifier:
	//	{SporadicQualifier} "sporadic" (instants+=Value ("," instants+=Expression)*)?;
	public SporadicQualifierElements getSporadicQualifierAccess() {
		return pSporadicQualifier;
	}
	
	public ParserRule getSporadicQualifierRule() {
		return getSporadicQualifierAccess().getRule();
	}

	//enum Type:
	//	TUNIT="U-clock" | TUNIT="unit-clock"
	//	| TINT="Z-clock" | TINT="int-clock"
	//	| TDEC="D-clock" | TDEC="decimal-clock"
	//	| TRAT="Q-clock" | TRAT="rational-clock"
	//	| TFLOAT="F-clock" | TFLOAT="float-clock" | TFLOAT="double-clock";
	public TypeElements getTypeAccess() {
		return eType;
	}
	
	public EnumRule getTypeRule() {
		return getTypeAccess().getRule();
	}

	//enum ValueType:
	//	TINT="int"
	//	| TDEC="decimal"
	//	| TRAT="rational"
	//	| TFLOAT="double" | TFLOAT="float";
	public ValueTypeElements getValueTypeAccess() {
		return eValueType;
	}
	
	public EnumRule getValueTypeRule() {
		return getValueTypeAccess().getRule();
	}

	//Relation:
	//	ImplicationRelation | TagRelation | AwaitImplication;
	public RelationElements getRelationAccess() {
		return pRelation;
	}
	
	public ParserRule getRelationRule() {
		return getRelationAccess().getRule();
	}

	//ImplicationRelation:
	//	source=[Clock] qual=ImplicationQualifier? "implies" target=[Clock];
	public ImplicationRelationElements getImplicationRelationAccess() {
		return pImplicationRelation;
	}
	
	public ParserRule getImplicationRelationRule() {
		return getImplicationRelationAccess().getRule();
	}

	//AwaitImplication:
	//	"await" masters+=[Clock]+ ("with" (weak?="weak" | strong?="strong") "reset" "on" reset=[Clock])? "implies"
	//	target=[Clock];
	public AwaitImplicationElements getAwaitImplicationAccess() {
		return pAwaitImplication;
	}
	
	public ParserRule getAwaitImplicationRule() {
		return getAwaitImplicationAccess().getRule();
	}

	//ImplicationQualifier:
	//	FilteredQualifier | EveryQualifier | DelayedQualifier | SustainedQualifier | TimeDelayedQualifier | WhenQualifier |
	//	NextQualifier;
	public ImplicationQualifierElements getImplicationQualifierAccess() {
		return pImplicationQualifier;
	}
	
	public ParserRule getImplicationQualifierRule() {
		return getImplicationQualifierAccess().getRule();
	}

	//FilteredQualifier:
	//	"filtered" "by" pattern=Pattern;
	public FilteredQualifierElements getFilteredQualifierAccess() {
		return pFilteredQualifier;
	}
	
	public ParserRule getFilteredQualifierRule() {
		return getFilteredQualifierAccess().getRule();
	}

	//EveryQualifier:
	//	"every" period=Expression (off?="starting" "at" offset=Expression)?;
	public EveryQualifierElements getEveryQualifierAccess() {
		return pEveryQualifier;
	}
	
	public ParserRule getEveryQualifierRule() {
		return getEveryQualifierAccess().getRule();
	}

	//DelayedQualifier:
	//	immediately?="immediately"? "delayed" "by" count=Expression (reset?="with" "reset")? "on" clock=[Clock];
	public DelayedQualifierElements getDelayedQualifierAccess() {
		return pDelayedQualifier;
	}
	
	public ParserRule getDelayedQualifierRule() {
		return getDelayedQualifierAccess().getRule();
	}

	//SustainedQualifier:
	//	"sustained" immediately?="immediately"?
	//	"from" startClock=[Clock] "to" endClock=[Clock] weakly?="weakly"?;
	public SustainedQualifierElements getSustainedQualifierAccess() {
		return pSustainedQualifier;
	}
	
	public ParserRule getSustainedQualifierRule() {
		return getSustainedQualifierAccess().getRule();
	}

	//TimeDelayedQualifier:
	//	"time" "delayed" "by" delay=Expression "on" clock=[Clock] (reset?="with" (immReset?="immediate"? &
	//	strongReset?="strong"?) "reset" "on" resetClock=[Clock])?
	//	//timeExpr=Expr
	//;
	public TimeDelayedQualifierElements getTimeDelayedQualifierAccess() {
		return pTimeDelayedQualifier;
	}
	
	public ParserRule getTimeDelayedQualifierRule() {
		return getTimeDelayedQualifierAccess().getRule();
	}

	//Let:
	//	"let" type=ValueType name=ID "=" value=Expression;
	public LetElements getLetAccess() {
		return pLet;
	}
	
	public ParserRule getLetRule() {
		return getLetAccess().getRule();
	}

	//Value:
	//	IntegerValue | DecimalValue | FloatValue | RationalValue | LetValue;
	public ValueElements getValueAccess() {
		return pValue;
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}

	//IntegerValue:
	//	sign=OpTerm? value=BIG_INT;
	public IntegerValueElements getIntegerValueAccess() {
		return pIntegerValue;
	}
	
	public ParserRule getIntegerValueRule() {
		return getIntegerValueAccess().getRule();
	}

	//DecimalValue:
	//	sign=OpTerm? value=BIG_DECIMAL;
	public DecimalValueElements getDecimalValueAccess() {
		return pDecimalValue;
	}
	
	public ParserRule getDecimalValueRule() {
		return getDecimalValueAccess().getRule();
	}

	//FloatValue:
	//	sign=OpTerm? value=FLOAT;
	public FloatValueElements getFloatValueAccess() {
		return pFloatValue;
	}
	
	public ParserRule getFloatValueRule() {
		return getFloatValueAccess().getRule();
	}

	//RationalValue:
	//	sign=OpTerm? value=RATIONAL;
	public RationalValueElements getRationalValueAccess() {
		return pRationalValue;
	}
	
	public ParserRule getRationalValueRule() {
		return getRationalValueAccess().getRule();
	}

	//LetValue:
	//	"$" ref=[Let];
	public LetValueElements getLetValueAccess() {
		return pLetValue;
	}
	
	public ParserRule getLetValueRule() {
		return getLetValueAccess().getRule();
	}

	//enum OpTerm returns Op:
	//	PLUS="+" | MINUS="-";
	public OpTermElements getOpTermAccess() {
		return eOpTerm;
	}
	
	public EnumRule getOpTermRule() {
		return getOpTermAccess().getRule();
	}

	//enum OpFact returns Op:
	//	TIMES="*" | DIV="/";
	public OpFactElements getOpFactAccess() {
		return eOpFact;
	}
	
	public EnumRule getOpFactRule() {
		return getOpFactAccess().getRule();
	}

	//Expression:
	//	Term;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}

	//Term Expression:
	//	Factor ({BinOp.left=current} op=OpTerm right=Factor)*;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}

	//Factor Expression:
	//	BasicExpr ({BinOp.left=current} op=OpFact right=BasicExpr)*;
	public FactorElements getFactorAccess() {
		return pFactor;
	}
	
	public ParserRule getFactorRule() {
		return getFactorAccess().getRule();
	}

	//BasicExpr Expression:
	//	Value | '(' Expression ')' | Cast;
	public BasicExprElements getBasicExprAccess() {
		return pBasicExpr;
	}
	
	public ParserRule getBasicExprRule() {
		return getBasicExprAccess().getRule();
	}

	//Cast:
	//	IntCast | DecimalCast | FloatCast | RationalCast;
	public CastElements getCastAccess() {
		return pCast;
	}
	
	public ParserRule getCastRule() {
		return getCastAccess().getRule();
	}

	//IntCast:
	//	"[int " expr=Expression "]";
	public IntCastElements getIntCastAccess() {
		return pIntCast;
	}
	
	public ParserRule getIntCastRule() {
		return getIntCastAccess().getRule();
	}

	//FloatCast:
	//	("[float " | "[double") expr=Expression "]";
	public FloatCastElements getFloatCastAccess() {
		return pFloatCast;
	}
	
	public ParserRule getFloatCastRule() {
		return getFloatCastAccess().getRule();
	}

	//DecimalCast:
	//	"[decimal" expr=Expression "]";
	public DecimalCastElements getDecimalCastAccess() {
		return pDecimalCast;
	}
	
	public ParserRule getDecimalCastRule() {
		return getDecimalCastAccess().getRule();
	}

	//RationalCast:
	//	"[rational " expr=Expression "]";
	public RationalCastElements getRationalCastAccess() {
		return pRationalCast;
	}
	
	public ParserRule getRationalCastRule() {
		return getRationalCastAccess().getRule();
	}

	//WhenQualifier:
	//	"when" not?="not"? clock=[Clock];
	public WhenQualifierElements getWhenQualifierAccess() {
		return pWhenQualifier;
	}
	
	public ParserRule getWhenQualifierRule() {
		return getWhenQualifierAccess().getRule();
	}

	//NextQualifier:
	//	strict?="strictly"? "next" "to" clock=[Clock];
	public NextQualifierElements getNextQualifierAccess() {
		return pNextQualifier;
	}
	
	public ParserRule getNextQualifierRule() {
		return getNextQualifierAccess().getRule();
	}

	//Pattern:
	//	skip=Expression "," keep=Expression (rep?="(" repskip=Expression "," repkeep=Expression ")" "*")?;
	public PatternElements getPatternAccess() {
		return pPattern;
	}
	
	public ParserRule getPatternRule() {
		return getPatternAccess().getRule();
	}

	//TagRelation:
	//	"tag" "relation" expr=TagExpr
	//	| "time" "relation" expr=TagExpr;
	public TagRelationElements getTagRelationAccess() {
		return pTagRelation;
	}
	
	public ParserRule getTagRelationRule() {
		return getTagRelationAccess().getRule();
	}

	//TagExpr:
	//	{TagExpr} clockY=[Clock] "=" (valueA=Expression "*")? clockX=[Clock] ("^" valueN=BasicExpr)? ("+" valueB=Expression)?;
	public TagExprElements getTagExprAccess() {
		return pTagExpr;
	}
	
	public ParserRule getTagExprRule() {
		return getTagExprAccess().getRule();
	}

	///*
	//TagExpr:
	//	SameTagsExpr | AffineTagsExpr | PowerTagExpr
	//;
	//
	//SameTagsExpr:
	//	{SameTagsExpr} clockY=[Clock | ID] eq="=" clockX=[Clock | ID]
	//;
	//
	//AffineTagsExpr:
	//	{AffineTagsExpr} clockY=[Clock | ID] eq="=" valueA=Expression "*" clockX=[Clock | ID] ("+" valueB=Expression)?
	//|	{AffineTagsExpr} clockY=[Clock | ID] eq="=" clockX=[Clock | ID] "+" valueB=Expression
	//;
	//
	//PowerTagExpr:
	//	{PowerTagExpr} clockY=[Clock | ID] eq="=" (valueA=BasicExpr "*")? clockX=[Clock | ID] "^" valueN=BasicExpr "+" valueB=Expression
	//;
	//*/ /*
	//TagEq:
	//	clock=[Clock | ID] "=" expr=Expr
	//;
	//
	///*
	//BinOp1:
	//	'*' | '/'
	//;
	//
	//BinOp2:
	//	'+' | '-'
	//;
	//
	//
	//Expr:
	//	Term ({BinOperation.left=current} operator=BinOp2 right=Term)*
	//;
	//
	//Term returns Expr:
	//	Factor ({BinOperation.left=current} operator=BinOp1 right=Factor)*
	//;
	//
	//Factor returns Expr:
	//	{ClockRef} clock=[Clock | ID] |
	//	{Litteral} value=Value |
	//	( '(' Expr ')' )
	//;
	//*/ Pragma:
	//	StopPragma | TagrefPragma | TracePragma | MaxstepPragma
	//	| OutputPragma | DoubleCalcPragma | DumpResultPragma;
	public PragmaElements getPragmaAccess() {
		return pPragma;
	}
	
	public ParserRule getPragmaRule() {
		return getPragmaAccess().getRule();
	}

	//StopPragma:
	//	"@stop" "when" clock=[Clock];
	public StopPragmaElements getStopPragmaAccess() {
		return pStopPragma;
	}
	
	public ParserRule getStopPragmaRule() {
		return getStopPragmaAccess().getRule();
	}

	//TagrefPragma:
	//	"@tagref" clock=[Clock];
	public TagrefPragmaElements getTagrefPragmaAccess() {
		return pTagrefPragma;
	}
	
	public ParserRule getTagrefPragmaRule() {
		return getTagrefPragmaAccess().getRule();
	}

	//TracePragma:
	//	"@trace" kinds+=ID ("," kinds+=ID)*;
	public TracePragmaElements getTracePragmaAccess() {
		return pTracePragma;
	}
	
	public ParserRule getTracePragmaRule() {
		return getTracePragmaAccess().getRule();
	}

	//MaxstepPragma:
	//	"@maxstep" value=Expression;
	public MaxstepPragmaElements getMaxstepPragmaAccess() {
		return pMaxstepPragma;
	}
	
	public ParserRule getMaxstepPragmaRule() {
		return getMaxstepPragmaAccess().getRule();
	}

	//OutputPragma:
	//	{OutputPragma} "@output" type=("vcd" | "tikz" | "svg") ((selection?="select" selectedClocks+=ClockItem (","
	//	selectedClocks+=ClockItem)*)?
	//	& (window?="from" from=Expression "to" to=Expression)?
	//	& ("label" "if" labelif+=[Clock] ("," labelif+=[Clock])*)?
	//	& (xscaled?="xscale" xscale=Expression)?
	//	& ("border" "=" border=STRING)?
	//	& ("css" "=" css=STRING)?
	//	& nodefcss?="no-default-css"?
	//	& ("javascript" "=" jvs=STRING)?
	//	& (standalone?="standalone" overwrite?="overwrite"?)?);
	public OutputPragmaElements getOutputPragmaAccess() {
		return pOutputPragma;
	}
	
	public ParserRule getOutputPragmaRule() {
		return getOutputPragmaAccess().getRule();
	}

	//// supports clock renaming (for long clock names)
	//ClockItem:
	//	clock=[Clock] ("->" newName=ID)?;
	public ClockItemElements getClockItemAccess() {
		return pClockItem;
	}
	
	public ParserRule getClockItemRule() {
		return getClockItemAccess().getRule();
	}

	//DoubleCalcPragma:
	//	"@doublecalc" "digits" "=" num_digits=BIG_INT (round?="(" rounding_mode=ROUNDING_MODE ")")?;
	public DoubleCalcPragmaElements getDoubleCalcPragmaAccess() {
		return pDoubleCalcPragma;
	}
	
	public ParserRule getDoubleCalcPragmaRule() {
		return getDoubleCalcPragmaAccess().getRule();
	}

	//DumpResultPragma:
	//	{DumpResultPragma} "@dumpres";
	public DumpResultPragmaElements getDumpResultPragmaAccess() {
		return pDumpResultPragma;
	}
	
	public ParserRule getDumpResultPragmaRule() {
		return getDumpResultPragmaAccess().getRule();
	}

	//enum ROUNDING_MODE:
	//	ROUND_UP="round_up"
	//	| ROUND_DOWN="round_down"
	//	| ROUND_CEILING="round_ceil"
	//	| ROUND_FLOOR="round_floor"
	//	| ROUND_HALF_UP="round_half_up"
	//	| ROUND_HALF_DOWN="round_half_down"
	//	| ROUND_HALF_EVEN="round_half_even";
	public ROUNDING_MODEElements getROUNDING_MODEAccess() {
		return eROUNDING_MODE;
	}
	
	public EnumRule getROUNDING_MODERule() {
		return getROUNDING_MODEAccess().getRule();
	}

	//terminal fragment DIGIT:
	//	'0'..'9';
	public TerminalRule getDIGITRule() {
		return tDIGIT;
	} 

	//terminal fragment SIGN:
	//	'+' | '-';
	public TerminalRule getSIGNRule() {
		return tSIGN;
	} 

	//terminal fragment EXPONENT:
	//	('e' | 'E') SIGN? DIGIT+;
	public TerminalRule getEXPONENTRule() {
		return tEXPONENT;
	} 

	//terminal BIG_INT returns ecore::EBigInteger:
	//	DIGIT+;
	public TerminalRule getBIG_INTRule() {
		return tBIG_INT;
	} 

	//terminal FLOAT returns ecore::EDouble:
	//	(DIGIT+ '.' DIGIT* EXPONENT? | // digits before decimal point
	//	'.' DIGIT+ EXPONENT? | DIGIT+ EXPONENT) 'F' // no decimal point, but exponent
	//;
	public TerminalRule getFLOATRule() {
		return tFLOAT;
	} 

	//terminal BIG_DECIMAL returns ecore::EBigDecimal:
	//	DIGIT+ '.' DIGIT* EXPONENT? | // digits before decimal point
	//	'.' DIGIT+ EXPONENT? | DIGIT+ EXPONENT // no decimal point, but exponent
	//;
	public TerminalRule getBIG_DECIMALRule() {
		return tBIG_DECIMAL;
	} 

	//terminal RATIONAL returns ecore::EJavaObject:
	//	'<' DIGIT+ '/' DIGIT+ '>';
	public TerminalRule getRATIONALRule() {
		return tRATIONAL;
	} 

	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	} 

	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	} 

	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	} 

	//terminal STRING:
	//	'"'->'"';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	} 
}
